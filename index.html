<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>motion</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background-color: #050505; color: white; font-family: system-ui, -apple-system, sans-serif; }
    canvas { display: block; }
    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0",
        "three": "https://esm.sh/three@0.160.0",
        "three/examples/jsm/": "https://esm.sh/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef } from 'react';
    import ReactDOM from 'react-dom/client';
    import { Settings2, RotateCcw } from 'lucide-react';
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
    import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes';
    import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
    import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
    import { RGBShiftShader } from 'three/examples/jsm/shaders/RGBShiftShader';
    import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
    import { BokehPass } from 'three/examples/jsm/postprocessing/BokehPass';
    import { SSAOPass } from 'three/examples/jsm/postprocessing/SSAOPass';

    const DEFAULT_CONFIG = {
      speed: 0.5,
      numBlobs: 30,
      resolution: 60,
      isolation: 35,
      floor: false,
      wallX: false,
      wallZ: false,
      color: '#FFFFFF',
      ambientLightBrightness: 60,
      materialType: 'striped',
      bloomStrength: 0.2,
      bloomRadius: 0.5,
      bloomThreshold: 0.9,
      focus: 1980.0,
      aperture: 0.00001,
      maxBlur: 0.01,
      enableSSAO: false,
      ssaoRadius: 16,
      ssaoMinDist: 0.005,
      ssaoMaxDist: 0.1,
      enableDoF: false,
      enableRGB: false,
      slicedMode: false,
      enableFeedback: false,
    };

    const ControlPanel = ({ config, setConfig }) => {
      const handleChange = (key, value) => {
        setConfig(prev => {
          const newConfig = { ...prev, [key]: value };
          if (key === 'slicedMode' && value === true) newConfig.materialType = 'striped';
          if (key === 'enableDoF' && value === true) newConfig.enableFeedback = false;
          if (key === 'materialType' && value === 'water') {
            newConfig.enableDoF = true;
            newConfig.enableRGB = true;
            newConfig.enableFeedback = false;
          }
          return newConfig;
        });
      };

      return (
        <div className="absolute top-4 left-4 w-80 bg-black/80 backdrop-blur-md border border-white/10 rounded-xl p-5 shadow-2xl text-sm z-50 max-h-[90vh] overflow-y-auto transition-opacity duration-300 opacity-0 hover:opacity-100 font-sans scrollbar-hide">
          <div className="flex items-center justify-between mb-6">
            <div className="flex items-center gap-2 text-indigo-400">
              <Settings2 size={20} />
              <h2 className="font-bold text-lg uppercase tracking-wider">Controls</h2>
            </div>
            <button onClick={() => setConfig(DEFAULT_CONFIG)} className="p-1.5 hover:bg-white/10 rounded-full transition-colors text-white/50 hover:text-white" title="Reset">
              <RotateCcw size={16} />
            </button>
          </div>
          <div className="space-y-5">
            <div className="space-y-2">
                <label className="text-xs font-semibold text-white/60 uppercase">Material</label>
                <div className="flex gap-2">
                    <button onClick={() => handleChange('materialType', 'striped')} className={`flex-1 py-2 rounded-lg border text-xs font-semibold transition-colors ${config.materialType === 'striped' ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10'}`}>Striped</button>
                    <button onClick={() => handleChange('materialType', 'water')} className={`flex-1 py-2 rounded-lg border text-xs font-semibold transition-colors ${config.materialType === 'water' ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10'}`}>Water</button>
                </div>
            </div>
            <div className="space-y-2">
                <label className="text-xs font-semibold text-white/60 uppercase">Base Color</label>
                <div className="flex items-center gap-3 bg-white/5 p-2 rounded-lg border border-white/10">
                <input type="color" value={config.color} onChange={(e) => handleChange('color', e.target.value)} className="w-8 h-8 rounded cursor-pointer bg-transparent border-none p-0" />
                <span className="font-mono text-white/80">{config.color}</span>
                </div>
            </div>
            <hr className="border-white/10" />
            <div className="space-y-2">
              <label className="text-xs font-semibold text-white/60 uppercase">Styles & Effects</label>
              <div className="space-y-2 pt-1">
                 <label className="flex items-center gap-3 cursor-pointer group">
                  <input type="checkbox" checked={config.slicedMode} onChange={(e) => handleChange('slicedMode', e.target.checked)} className="appearance-none w-4 h-4 rounded border border-white/20 bg-white/5 checked:bg-indigo-500 checked:border-indigo-500 transition-colors" />
                  <span className="text-white/80 group-hover:text-white transition-colors">Sliced Mode</span>
                </label>
                <label className="flex items-center gap-3 cursor-pointer group">
                  <input type="checkbox" checked={config.enableFeedback} onChange={(e) => handleChange('enableFeedback', e.target.checked)} className="appearance-none w-4 h-4 rounded border border-white/20 bg-white/5 checked:bg-indigo-500 checked:border-indigo-500 transition-colors" disabled={config.enableDoF} />
                  <span className={`text-white/80 transition-colors ${config.enableDoF ? 'opacity-50 cursor-not-allowed' : 'group-hover:text-white'}`}>Feedback Trail</span>
                </label>
              </div>
            </div>
            <hr className="border-white/10" />
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                  <label className="text-xs font-semibold text-white/60 uppercase">Ambient Occlusion (SSGI)</label>
                  <input type="checkbox" checked={config.enableSSAO} onChange={(e) => handleChange('enableSSAO', e.target.checked)} className="appearance-none w-4 h-4 rounded border border-white/20 bg-white/5 checked:bg-indigo-500 checked:border-indigo-500 transition-colors cursor-pointer" />
              </div>
              {config.enableSSAO && (
                <div className="pl-2 border-l-2 border-indigo-500/20 space-y-3 mt-2">
                    <div className="space-y-1">
                        <div className="flex justify-between"><label className="text-[10px] text-white/50">Radius</label><span className="text-[10px] font-mono text-indigo-400">{config.ssaoRadius}</span></div>
                        <input type="range" min="1" max="32" step="1" value={config.ssaoRadius} onChange={(e) => handleChange('ssaoRadius', parseFloat(e.target.value))} className="w-full accent-indigo-500 h-1 bg-white/10 rounded-lg appearance-none cursor-pointer" />
                    </div>
                </div>
              )}
            </div>
            <hr className="border-white/10" />
            <div className="space-y-2">
              <label className="text-xs font-semibold text-white/60 uppercase">Post Processing</label>
              <div className="space-y-2 pt-1">
                <label className="flex items-center gap-3 cursor-pointer group">
                  <input type="checkbox" checked={config.enableDoF} onChange={(e) => handleChange('enableDoF', e.target.checked)} className="appearance-none w-4 h-4 rounded border border-white/20 bg-white/5 checked:bg-indigo-500 checked:border-indigo-500 transition-colors" />
                  <span className="text-white/80 group-hover:text-white transition-colors">Depth of Field <span className="text-white/40 text-[10px] ml-1">(disables feedback)</span></span>
                </label>
                <label className="flex items-center gap-3 cursor-pointer group">
                  <input type="checkbox" checked={config.enableRGB} onChange={(e) => handleChange('enableRGB', e.target.checked)} className="appearance-none w-4 h-4 rounded border border-white/20 bg-white/5 checked:bg-indigo-500 checked:border-indigo-500 transition-colors" />
                  <span className="text-white/80 group-hover:text-white transition-colors">RGB Shift</span>
                </label>
              </div>
            </div>
            <hr className="border-white/10" />
            <div className="space-y-4">
              <div className="space-y-1">
                <div className="flex justify-between"><label className="text-xs font-semibold text-white/60">Speed</label><span className="text-xs font-mono text-indigo-400">{config.speed.toFixed(1)}x</span></div>
                <input type="range" min="0" max="5" step="0.1" value={config.speed} onChange={(e) => handleChange('speed', parseFloat(e.target.value))} className="w-full accent-indigo-500 h-1 bg-white/10 rounded-lg appearance-none cursor-pointer" />
              </div>
              <div className="space-y-1">
                 <div className="flex justify-between"><label className="text-xs font-semibold text-white/60">Resolution</label><span className="text-xs font-mono text-indigo-400">{config.resolution}</span></div>
                <input type="range" min="10" max="100" step="1" value={config.resolution} onChange={(e) => handleChange('resolution', parseInt(e.target.value))} className="w-full accent-indigo-500 h-1 bg-white/10 rounded-lg appearance-none cursor-pointer" />
                <p className="text-[10px] text-white/30 pt-1">Higher resolution impacts performance.</p>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const ThreeScene = ({ config }) => {
      const containerRef = useRef(null);
      const feedbackCanvasRef = useRef(null);
      const rendererRef = useRef(null);
      const sceneRef = useRef(null);
      const cameraRef = useRef(null);
      const effectRef = useRef(null);
      const controlsRef = useRef(null);
      const animationIdRef = useRef(null);
      const timeRef = useRef(0);
      const composerRef = useRef(null);
      const bloomPassRef = useRef(null);
      const bokehPassRef = useRef(null);
      const rgbPassRef = useRef(null);
      const ssaoPassRef = useRef(null);
      const ambientLightRef = useRef(null);

      useEffect(() => {
        if (!containerRef.current) return;
        const width = window.innerWidth;
        const height = window.innerHeight;
        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, preserveDrawingBuffer: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.setClearColor(0x020202, 1);
        containerRef.current.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020202);
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        pmremGenerator.dispose();
        sceneRef.current = scene;

        const camera = new THREE.PerspectiveCamera(50, width / height, 1, 50000);
        camera.position.set(0, 0, 2000); 
        cameraRef.current = camera;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.minDistance = 200;
        controls.maxDistance = 4000;
        controls.enableDamping = true;
        controlsRef.current = controls;

        const overheadLight = new THREE.DirectionalLight(0xffffff, 0.5); 
        overheadLight.position.set(0, 2000, 0);
        overheadLight.castShadow = true;
        overheadLight.shadow.mapSize.width = 2048;
        overheadLight.shadow.mapSize.height = 2048;
        overheadLight.shadow.camera.near = 0.5;
        overheadLight.shadow.camera.far = 5000;
        overheadLight.shadow.camera.left = -1000;
        overheadLight.shadow.camera.right = 1000;
        overheadLight.shadow.camera.top = 1000;
        overheadLight.shadow.camera.bottom = -1000;
        overheadLight.shadow.bias = -0.0001;
        scene.add(overheadLight);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        ambientLightRef.current = ambientLight;

        const renderTarget = new THREE.WebGLRenderTarget(width, height, {
            type: THREE.HalfFloatType,
            format: THREE.RGBAFormat,
            depthTexture: new THREE.DepthTexture(width, height),
            depthBuffer: true,
            samples: 4
        });

        const composer = new EffectComposer(renderer, renderTarget);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const ssaoPass = new SSAOPass(scene, camera, width, height);
        ssaoPass.kernelRadius = 16;
        ssaoPass.minDistance = 0.005;
        ssaoPass.maxDistance = 0.1;
        ssaoPass.enabled = false;
        ssaoPassRef.current = ssaoPass;
        composer.addPass(ssaoPass);

        const bokehPass = new BokehPass(scene, camera, { focus: config.focus, aperture: config.aperture, maxblur: config.maxBlur });
        bokehPass.enabled = false;
        bokehPassRef.current = bokehPass;
        composer.addPass(bokehPass);

        const bloomPass = new UnrealBloomPass( new THREE.Vector2( width, height ), 1.5, 0.4, 0.85 );
        bloomPassRef.current = bloomPass;
        composer.addPass( bloomPass );

        const rgbShiftPass = new ShaderPass(RGBShiftShader);
        rgbShiftPass.uniforms['amount'].value = 0.001;
        rgbShiftPass.enabled = false;
        rgbPassRef.current = rgbShiftPass;
        composer.addPass(rgbShiftPass);

        const outputPass = new OutputPass();
        composer.addPass(outputPass);
        composerRef.current = composer;

        if (feedbackCanvasRef.current) {
            feedbackCanvasRef.current.width = width;
            feedbackCanvasRef.current.height = height;
        }

        const handleResize = () => {
          const w = window.innerWidth;
          const h = window.innerHeight;
          if (cameraRef.current && rendererRef.current) {
            cameraRef.current.aspect = w / h;
            cameraRef.current.updateProjectionMatrix();
            rendererRef.current.setSize(w, h);
            if (composerRef.current) {
                composerRef.current.setSize(w, h);
                composerRef.current.renderTarget1.setSize(w, h);
                if (ssaoPassRef.current) ssaoPassRef.current.setSize(w, h);
            }
            if (feedbackCanvasRef.current) {
                feedbackCanvasRef.current.width = w;
                feedbackCanvasRef.current.height = h;
                const ctx = feedbackCanvasRef.current.getContext('2d');
                if(ctx) { ctx.fillStyle = '#000000'; ctx.fillRect(0,0,w,h); }
            }
          }
        };
        window.addEventListener('resize', handleResize);

        return () => {
          window.removeEventListener('resize', handleResize);
          if (rendererRef.current) rendererRef.current.dispose();
          if (containerRef.current && rendererRef.current?.domElement) containerRef.current.removeChild(rendererRef.current.domElement);
          if (animationIdRef.current) cancelAnimationFrame(animationIdRef.current);
        };
      }, []);

      useEffect(() => {
        if (!rendererRef.current || !sceneRef.current) return;
        if (config.enableFeedback) {
          sceneRef.current.background = null; 
          rendererRef.current.setClearColor(0x000000, 0); 
        } else {
          sceneRef.current.background = new THREE.Color(0x020202);
          rendererRef.current.setClearColor(0x020202, 1);
        }
      }, [config.enableFeedback]);

      useEffect(() => { if (ambientLightRef.current) ambientLightRef.current.intensity = config.ambientLightBrightness * 0.01; }, [config.ambientLightBrightness]);

      useEffect(() => {
        if (bokehPassRef.current) bokehPassRef.current.enabled = config.enableDoF;
        if (rgbPassRef.current) rgbPassRef.current.enabled = config.enableRGB;
        if (ssaoPassRef.current) {
            ssaoPassRef.current.enabled = config.enableSSAO;
            ssaoPassRef.current.kernelRadius = config.ssaoRadius;
            ssaoPassRef.current.minDistance = config.ssaoMinDist;
            ssaoPassRef.current.maxDistance = config.ssaoMaxDist;
        }
      }, [config.enableDoF, config.enableRGB, config.enableSSAO, config.ssaoRadius, config.ssaoMinDist, config.ssaoMaxDist]);

      useEffect(() => {
        if (bloomPassRef.current) {
          bloomPassRef.current.threshold = config.bloomThreshold;
          bloomPassRef.current.strength = config.bloomStrength;
          bloomPassRef.current.radius = config.bloomRadius;
        }
      }, [config.bloomThreshold, config.bloomStrength, config.bloomRadius]);

      useEffect(() => {
          if (bokehPassRef.current) {
              bokehPassRef.current.uniforms['focus'].value = config.focus;
              bokehPassRef.current.uniforms['aperture'].value = config.aperture;
              bokehPassRef.current.uniforms['maxblur'].value = config.maxBlur;
          }
      }, [config.focus, config.aperture, config.maxBlur]);

      useEffect(() => {
        if (!sceneRef.current) return;
        if (effectRef.current) {
          sceneRef.current.remove(effectRef.current);
          if (effectRef.current.geometry) effectRef.current.geometry.dispose();
          if (!Array.isArray(effectRef.current.material)) effectRef.current.material.dispose();
          effectRef.current = null;
        }

        let material;
        if (config.materialType === 'water') {
            material = new THREE.MeshPhysicalMaterial({
                color: config.color,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.95,
                thickness: 20,
                ior: 1.33,
                side: THREE.DoubleSide,
                envMapIntensity: 1.5,
                clearcoat: 1.0,
                attenuationColor: new THREE.Color(config.color),
                attenuationDistance: 2000.0
            });
        } else {
            const vertexShader = `varying vec3 vPos; void main() { vPos = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
            const fragmentShader = `uniform vec3 uColor; uniform float uSliced; varying vec3 vPos; void main() { float frequency = 200.0; float v = sin(vPos.y * frequency); float line = smoothstep(0.98, 0.999, v); if (uSliced > 0.5) { if (line < 0.1) discard; } vec3 finalColor = uColor * line; gl_FragColor = vec4(finalColor, 1.0); }`;
            material = new THREE.ShaderMaterial({
              uniforms: { uColor: { value: new THREE.Color(config.color) }, uSliced: { value: config.slicedMode ? 1.0 : 0.0 } },
              vertexShader, fragmentShader, side: THREE.DoubleSide
            });
        }

        const effect = new MarchingCubes(config.resolution, material, true, true, 100000);
        effect.position.set(0, 0, 0);
        effect.scale.set(800, 800, 800); 
        effect.enableUvs = false;
        effect.enableColors = false;
        effect.castShadow = true;
        effect.receiveShadow = true;
        sceneRef.current.add(effect);
        effectRef.current = effect;
      }, [config.resolution, config.color, config.materialType]); 

      useEffect(() => {
        if (!sceneRef.current || !rendererRef.current || !cameraRef.current) return;
        const updateCubes = (object, time) => {
          object.reset();
          const subtract = 12;
          const strength = 1.2 / ((Math.sqrt(config.numBlobs) - 1) / 4 + 1);
          for (let i = 0; i < config.numBlobs; i++) {
            const ballx = Math.sin(i + 1.26 * time * (1.03 + 0.5 * Math.cos(0.21 * i))) * 0.25 + 0.5;
            const bally = Math.cos(i + 1.12 * time * Math.cos(1.22 + 0.1424 * i)) * 0.25 + 0.5; 
            const ballz = Math.cos(i + 1.32 * time * 0.1 * Math.sin((0.92 + 0.53 * i))) * 0.25 + 0.5;
            object.addBall(ballx, bally, ballz, strength, subtract);
          }
          if (config.floor) object.addPlaneY(2, 12);
          if (config.wallZ) object.addPlaneZ(2, 12);
          if (config.wallX) object.addPlaneX(2, 12);
          object.isolation = config.isolation;
        };

        const animate = () => {
          animationIdRef.current = requestAnimationFrame(animate);
          const delta = 0.01 * config.speed; 
          timeRef.current += delta;
          if (effectRef.current) {
            updateCubes(effectRef.current, timeRef.current);
            effectRef.current.update(); 
            effectRef.current.rotation.x = Math.sin(timeRef.current * 0.5) + Math.sin(timeRef.current * 0.32) * 2;
            effectRef.current.rotation.y = Math.cos(timeRef.current * 0.4) + Math.sin(timeRef.current * 0.15) * 2;
            if (config.materialType === 'striped') {
                const mat = effectRef.current.material;
                if (mat.uniforms) {
                    if (mat.uniforms.uColor) mat.uniforms.uColor.value.set(config.color);
                    if (mat.uniforms.uSliced) mat.uniforms.uSliced.value = config.slicedMode ? 1.0 : 0.0;
                }
            } else if (config.materialType === 'water') {
                effectRef.current.material.color.set(config.color);
                if (effectRef.current.material.attenuationColor) {
                    effectRef.current.material.attenuationColor.set(config.color);
                }
            }
          }
          if (controlsRef.current) controlsRef.current.update();
          if (composerRef.current) composerRef.current.render();
          if (config.enableFeedback && feedbackCanvasRef.current && rendererRef.current) {
              const ctx = feedbackCanvasRef.current.getContext('2d');
              if (ctx) {
                  const canvas = feedbackCanvasRef.current;
                  ctx.save();
                  ctx.imageSmoothingEnabled = false;
                  ctx.translate(canvas.width / 2, canvas.height / 2);
                  ctx.rotate(0.005);
                  ctx.scale(1.003, 1.003);
                  ctx.translate(-canvas.width / 2, -canvas.height / 2);
                  ctx.drawImage(canvas, 0, 0);
                  ctx.restore();
                  ctx.globalAlpha = 0.7;
                  ctx.drawImage(rendererRef.current.domElement, 0, 0, canvas.width, canvas.height);
                  ctx.globalAlpha = 1.0;
              }
          }
        };
        if (!animationIdRef.current) animate();
        return () => {
          if (animationIdRef.current) { cancelAnimationFrame(animationIdRef.current); animationIdRef.current = null; }
        };
      }, [config.speed, config.numBlobs, config.isolation, config.floor, config.wallX, config.wallZ, config.color, config.slicedMode, config.enableFeedback, config.materialType]);

      return (
        <React.Fragment>
          <canvas ref={feedbackCanvasRef} className="absolute inset-0 z-0 bg-black pointer-events-none" style={{ opacity: config.enableFeedback ? 1 : 0 }} />
          <div ref={containerRef} className="absolute inset-0 z-10 cursor-move" />
        </React.Fragment>
      );
    };

    const App = () => {
      const [config, setConfig] = useState(DEFAULT_CONFIG);
      return (
        <div className="relative w-full h-screen overflow-hidden font-sans">
          <ControlPanel config={config} setConfig={setConfig} />
          <ThreeScene config={config} />
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
