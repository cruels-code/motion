<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>motion</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Montserrat Font Import -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <style>
    body { margin: 0; overflow: hidden; background-color: #000; color: #e2e8f0; font-family: 'Montserrat', sans-serif; }
    
    /* Ensure form elements inherit the font */
    button, input, select, textarea {
      font-family: inherit;
    }

    canvas { display: block; touch-action: none; }
    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    
    /* Custom Range Slider Styling for Premium Feel */
    input[type=range] {
      -webkit-appearance: none; 
      background: transparent; 
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 14px;
      width: 14px;
      border-radius: 50%;
      background: #ffffff;
      margin-top: -5px; 
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
      cursor: pointer;
    }
    input[type=range]::-webkit-slider-runnable-track {
      width: 100%;
      height: 4px;
      cursor: pointer;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0",
        "three": "https://esm.sh/three@0.160.0",
        "three/examples/jsm/": "https://esm.sh/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef } from 'react';
    import ReactDOM from 'react-dom/client';
    import { Settings2, RotateCcw, X, ChevronDown } from 'lucide-react';
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
    import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes';
    import { Reflector } from 'three/examples/jsm/objects/Reflector.js';
    import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
    import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
    import { RGBShiftShader } from 'three/examples/jsm/shaders/RGBShiftShader';
    import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
    import { BokehPass } from 'three/examples/jsm/postprocessing/BokehPass';
    import { SSAOPass } from 'three/examples/jsm/postprocessing/SSAOPass';
    import { GTAOPass } from 'three/examples/jsm/postprocessing/GTAOPass';
    import { RectAreaLightUniformsLib } from 'three/examples/jsm/lights/RectAreaLightUniformsLib.js';
    import { RectAreaLightHelper } from 'three/examples/jsm/helpers/RectAreaLightHelper.js';

    // Custom Noise Shader
    const NoiseShader = {
      uniforms: {
        tDiffuse: { value: null },
        uTime: { value: 0 },
        uOpacity: { value: 0 },
        uBlendMode: { value: 0 } // 0: Overlay, 1: Multiply, 2: Additive, 3: SoftLight
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uOpacity;
        uniform int uBlendMode;
        varying vec2 vUv;

        // Gold Noise function - high quality, no patterns
        float rand(vec2 xy) {
            return fract(tan(distance(xy * 1.61803398874989484820459, xy) * uTime) * xy.x);
        }
        
        // Backup standard hash if Gold Noise is too heavy or specific
        float randStandard(vec2 co) {
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main() {
            vec4 base = texture2D(tDiffuse, vUv);
            
            // Using a simpler robust hash for static-like noise
            vec2 seed = gl_FragCoord.xy * 0.01 + mod(uTime, 100.0);
            float noise = randStandard(seed * 100.0);

            vec3 result = base.rgb;
            
            // 0: Overlay
            if (uBlendMode == 0) {
                for (int i = 0; i < 3; i++) {
                    float b = base.rgb[i];
                    if (b < 0.5) {
                        result[i] = 2.0 * b * noise;
                    } else {
                        result[i] = 1.0 - 2.0 * (1.0 - b) * (1.0 - noise);
                    }
                }
            }
            // 1: Multiply
            else if (uBlendMode == 1) {
                result = base.rgb * noise;
            }
            // 2: Additive
            else if (uBlendMode == 2) {
                result = base.rgb + noise;
            }
            // 3: SoftLight
            else if (uBlendMode == 3) {
                for (int i = 0; i < 3; i++) {
                    float b = base.rgb[i];
                    float n = noise;
                    result[i] = (1.0 - 2.0 * n) * b * b + 2.0 * n * b;
                }
            }

            // Apply opacity
            gl_FragColor = vec4(mix(base.rgb, result, uOpacity), base.a);
        }
      `
    };

    const DEFAULT_CONFIG = {
      speed: 0.5, numBlobs: 32, resolution: 60, isolation: 35,
      floor: false, // Standard MC floor (internal)
      enableReflectiveFloor: true, // New Glossy Floor
      wallX: false, wallZ: false,
      color: '#ffaa33', ambientLightBrightness: 80, materialType: 'wax',
      bloomStrength: 0.3, bloomRadius: 0.5, bloomThreshold: 0.9,
      focus: 1980.0, aperture: 0.00001, maxBlur: 0.01,
      enableSSAO: true, ssaoRadius: 16, ssaoMinDist: 0.005, ssaoMaxDist: 0.1,
      enableDoF: true, enableRGB: true, slicedMode: true,
      enableVolumeLights: true, enableFog: true,
      noiseOpacity: 0.1, noiseBlendMode: 'softlight'
    };

    const Toggle = ({ label, checked, onChange }) => (
      <label className="flex items-center justify-between cursor-pointer group py-2">
        <span className="text-gray-300 text-xs font-medium group-hover:text-white transition-colors tracking-wide">{label}</span>
        <div className="relative">
          <input type="checkbox" checked={checked} onChange={(e) => onChange(e.target.checked)} className="sr-only peer" />
          <div className="w-9 h-5 bg-white/10 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white/80 after:border-gray-300 after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-indigo-600 peer-checked:after:bg-white shadow-inner"></div>
        </div>
      </label>
    );

    const ControlPanel = ({ config, setConfig }) => {
      const [isOpen, setIsOpen] = useState(false);
      const [isMobile, setIsMobile] = useState(false);
      const [isColorActive, setIsColorActive] = useState(false);
      const isHovering = useRef(false);
      
      useEffect(() => {
        const check = () => setIsMobile(window.innerWidth < 768);
        check();
        window.addEventListener('resize', check);
        return () => window.removeEventListener('resize', check);
      }, []);

      const update = (k, v) => setConfig(p => ({ ...p, [k]: v }));

      // Dark Premium Theme Classes
      const panelClasses = isMobile 
        ? `fixed inset-0 z-[60] bg-[#050505]/95 backdrop-blur-xl p-6 overflow-y-auto transition-transform duration-500 cubic-bezier(0.16, 1, 0.3, 1) ${isOpen ? 'translate-y-0' : 'translate-y-full'}`
        : `absolute top-6 left-6 w-80 bg-[#080808]/60 backdrop-blur-2xl border border-white/5 rounded-2xl p-6 shadow-[0_20px_50px_-12px_rgba(0,0,0,1)] text-sm z-50 max-h-[90vh] overflow-y-auto transition-all duration-500 cubic-bezier(0.16, 1, 0.3, 1) scrollbar-hide ${isOpen ? 'opacity-100 pointer-events-auto translate-x-0' : 'opacity-0 pointer-events-none -translate-x-4'}`;

      const labelClass = "text-[10px] font-bold tracking-[0.2em] text-gray-500 uppercase mb-3 block";
      const valueClass = "font-mono text-indigo-400 text-[10px]";
      const borderClass = "border-white/5 my-6";
      const sectionClass = "mb-6";

      return (
        <>
          <div 
            className="absolute top-6 left-6 z-40"
            onMouseEnter={() => !isMobile && setIsOpen(true)}
          >
             <button 
               onClick={() => setIsOpen(true)}
               className={`p-3 rounded-2xl bg-black/40 backdrop-blur-xl border border-white/10 text-white shadow-2xl transition-all duration-300 hover:bg-black/60 hover:scale-105 active:scale-95 group ${(isOpen && !isMobile) ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}
             >
               <Settings2 size={20} className="group-hover:rotate-90 transition-transform duration-700" />
             </button>
          </div>

          <div 
            className={panelClasses}
            onMouseEnter={() => { isHovering.current = true; }}
            onMouseLeave={() => { 
                isHovering.current = false;
                if (!isMobile && !isColorActive) setIsOpen(false);
            }}
          >
            <div className="flex justify-between mb-8 items-center">
              <div className="flex gap-3 items-center">
                <div className="p-1.5 bg-indigo-500/10 rounded-lg border border-indigo-500/20">
                  <Settings2 size={16} className="text-indigo-400" />
                </div>
                <h2 className="font-semibold text-white tracking-wide text-sm">CONFIGURATION</h2>
              </div>
              <div className="flex gap-2 items-center">
                <button 
                  onClick={() => setConfig(DEFAULT_CONFIG)} 
                  className="p-2 rounded-full hover:bg-white/10 transition-colors text-gray-400 hover:text-white"
                  title="Reset to Defaults"
                >
                  <RotateCcw size={14} />
                </button>
                {isMobile && (
                  <button onClick={() => setIsOpen(false)} className="p-2 bg-white/5 rounded-full text-gray-200">
                    <X size={18} />
                  </button>
                )}
              </div>
            </div>
            
            <div className="pb-4">
              <div className={sectionClass}>
                <label className={labelClass}>Material Definition</label>
                <div className="grid grid-cols-2 gap-2">
                  {['wax', 'water', 'plaster', 'striped'].map(type => (
                    <button key={type} onClick={() => update('materialType', type)} 
                      className={`py-2.5 rounded-lg text-[11px] font-medium uppercase tracking-wider transition-all duration-300 border ${config.materialType === type ? 'bg-indigo-600/90 border-indigo-500/50 text-white shadow-lg shadow-indigo-900/50' : 'bg-white/5 border-transparent text-gray-400 hover:bg-white/10 hover:text-gray-200'}`}>
                      {type}
                    </button>
                  ))}
                </div>
              </div>

              <div className={sectionClass}>
                <label className={labelClass}>Base Chromaticity</label>
                <div className="flex items-center gap-3 p-1 pr-3 rounded-xl border border-white/5 bg-white/[0.02]">
                  <div className="relative overflow-hidden w-8 h-8 rounded-lg shadow-inner">
                    <input 
                      type="color" 
                      value={config.color} 
                      onChange={(e) => update('color', e.target.value)} 
                      onFocus={() => setIsColorActive(true)}
                      onBlur={() => {
                        setIsColorActive(false);
                        if (!isMobile && !isHovering.current) setIsOpen(false);
                      }}
                      className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[150%] h-[150%] cursor-pointer border-none p-0" 
                    />
                  </div>
                  <span className="font-mono text-xs text-gray-300 flex-1 text-center">{config.color.toUpperCase()}</span>
                </div>
              </div>

              <hr className={borderClass} />
              
              <div className={sectionClass}>
                <label className={labelClass}>Scene Effects</label>
                <div className="space-y-1">
                   <Toggle label="Sliced Mode" checked={config.slicedMode} onChange={(v) => update('slicedMode', v)} />
                   <Toggle label="Volume Lights" checked={config.enableVolumeLights} onChange={(v) => update('enableVolumeLights', v)} />
                   <Toggle label="Volumetric Fog" checked={config.enableFog} onChange={(v) => update('enableFog', v)} />
                   <Toggle label="Reflective Floor" checked={config.enableReflectiveFloor} onChange={(v) => update('enableReflectiveFloor', v)} />
                </div>
              </div>

              <hr className={borderClass} />

              <div className={sectionClass}>
                 <div className="flex justify-between items-end mb-3">
                   <label className="text-[10px] font-bold tracking-[0.2em] text-gray-500 uppercase">Bloom Strength</label>
                   <span className={valueClass}>{config.bloomStrength.toFixed(2)}</span>
                 </div>
                 <input type="range" min="0" max="3" step="0.05" value={config.bloomStrength} onChange={(e) => update('bloomStrength', +e.target.value)} className="w-full" />
              </div>
              
              <hr className={borderClass} />

              <div className={sectionClass}>
                 <div className="flex justify-between items-end mb-3">
                   <label className="text-[10px] font-bold tracking-[0.2em] text-gray-500 uppercase">Film Grain</label>
                   <span className={valueClass}>{Math.round(config.noiseOpacity * 100)}%</span>
                 </div>
                 <input type="range" min="0" max="1" step="0.01" value={config.noiseOpacity} onChange={(e) => update('noiseOpacity', +e.target.value)} className="w-full mb-4" />
                 
                 <div className="grid grid-cols-4 gap-1">
                  {['overlay', 'multiply', 'additive', 'softlight'].map(mode => (
                      <button key={mode} onClick={() => update('noiseBlendMode', mode)}
                          title={mode}
                          className={`py-2 rounded text-[10px] uppercase font-bold transition-all ${config.noiseBlendMode === mode ? 'bg-white/20 text-white' : 'bg-transparent text-gray-600 hover:text-gray-400'}`}>
                          {mode.slice(0,3)}
                      </button>
                  ))}
                 </div>
              </div>

              <hr className={borderClass} />

              <div className={sectionClass}>
                <div className="flex justify-between items-center mb-1">
                  <label className="text-[10px] font-bold tracking-[0.2em] text-gray-500 uppercase">AO Radius</label>
                  <Toggle label="" checked={config.enableSSAO} onChange={(v) => update('enableSSAO', v)} />
                </div>
                {config.enableSSAO && (
                  <div className="mt-2 animate-in fade-in slide-in-from-top-1 duration-300">
                     <div className="flex justify-between text-[10px] text-gray-500 mb-2"><span>Radius Size</span><span className={valueClass}>{config.ssaoRadius}</span></div>
                     <input type="range" min="1" max="32" value={config.ssaoRadius} onChange={(e) => update('ssaoRadius', +e.target.value)} className="w-full" />
                  </div>
                )}
              </div>

              <hr className={borderClass} />

              <div className={sectionClass}>
                <label className={labelClass}>Post Processing</label>
                <div className="space-y-1">
                   <Toggle label="Depth of Field" checked={config.enableDoF} onChange={(v) => update('enableDoF', v)} />
                   
                   {config.enableDoF && (
                      <div className="mt-2 mb-3 pl-2 animate-in fade-in slide-in-from-top-1 duration-300 border-l-2 border-white/10">
                         <div className="flex justify-between text-[10px] text-gray-500 mb-1">
                            <span>Focus Distance</span>
                            <span className={valueClass}>{config.focus.toFixed(0)}</span>
                         </div>
                         <input 
                           type="range" 
                           min="10" 
                           max="3000" 
                           step="10" 
                           value={config.focus} 
                           onChange={(e) => update('focus', +e.target.value)} 
                           className="w-full" 
                         />
                      </div>
                   )}

                   <Toggle label="RGB Shift" checked={config.enableRGB} onChange={(v) => update('enableRGB', v)} />
                </div>
              </div>

              <hr className={borderClass} />

              <div className="space-y-5">
                {[
                  { label: 'Speed', key: 'speed', min: 0, max: 5, step: 0.1, fmt: v => v.toFixed(1) + 'x' },
                  { label: 'Resolution', key: 'resolution', min: 10, max: 100, step: 1, fmt: v => v }
                ].map(ctrl => (
                  <div key={ctrl.key}>
                    <div className="flex justify-between text-xs mb-2">
                        <span className="text-gray-300 font-medium">{ctrl.label}</span>
                        <span className={valueClass}>{ctrl.fmt(config[ctrl.key])}</span>
                    </div>
                    <input type="range" min={ctrl.min} max={ctrl.max} step={ctrl.step} value={config[ctrl.key]} onChange={(e) => update(ctrl.key, +e.target.value)} className="w-full" />
                  </div>
                ))}
              </div>
              
              <div className="mt-8 text-[10px] text-center text-gray-700 font-medium tracking-widest uppercase opacity-50">
                Render Engine v2.0
              </div>
            </div>
          </div>
        </>
      );
    };

    const ThreeScene = ({ config }) => {
      const containerRef = useRef(null);
      const ctx = useRef({}); // Context to store refs

      // Initialize Scene
      useEffect(() => {
        if (!containerRef.current) return;
        
        // Init RectAreaLight Uniforms
        RectAreaLightUniformsLib.init();

        const width = window.innerWidth, height = window.innerHeight;
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, preserveDrawingBuffer: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for mobile performance
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.setClearColor(0x000000, 0);
        containerRef.current.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const pmrem = new THREE.PMREMGenerator(renderer);
        const roomEnv = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
        scene.environment = roomEnv;
        pmrem.dispose();

        const camera = new THREE.PerspectiveCamera(50, width / height, 1, 50000);
        camera.position.set(0, -300, 2400);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.minDistance = 200; controls.maxDistance = 4000; controls.enableDamping = true;

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(0, 2000, 0);
        dirLight.castShadow = true;
        Object.assign(dirLight.shadow.camera, { near: 0.5, far: 5000, left: -1000, right: 1000, top: 1000, bottom: -1000 });
        dirLight.shadow.mapSize.set(2048, 2048);
        scene.add(dirLight);

        const ambLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambLight);
        
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.0);
        hemiLight.position.set(0, 2000, 0);
        scene.add(hemiLight);

        // Volume Lights Group
        const volGroup = new THREE.Group();
        scene.add(volGroup);

        // Reflective Floor Group
        const floorGroup = new THREE.Group();
        scene.add(floorGroup);
        
        // 1. Reflector (Mirror)
        // Positioned at y = -800 (raised 50 units from -850)
        // Size increased by 10x (5000 -> 50000)
        const mirrorGeo = new THREE.PlaneGeometry(50000, 50000);
        const groundMirror = new Reflector(mirrorGeo, {
            clipBias: 0.003,
            textureWidth: window.innerWidth * window.devicePixelRatio,
            textureHeight: window.innerHeight * window.devicePixelRatio,
            color: 0x111111 // Dark base for "black glossy" look
        });
        groundMirror.position.y = -800; 
        groundMirror.rotateX(-Math.PI / 2);
        floorGroup.add(groundMirror);
        
        // 2. Grid (Tiles)
        // Positioned slightly above the mirror
        // Size increased by 10x (5000 -> 50000), Divisions increased by 10x (50 -> 500) to keep cell density
        const grid = new THREE.GridHelper(50000, 500, 0x222222, 0x222222);
        grid.position.y = -799;
        grid.material.transparent = true;
        grid.material.opacity = 0.3;
        floorGroup.add(grid);

        // Post-processing
        const target = new THREE.WebGLRenderTarget(width, height, { type: THREE.HalfFloatType, depthTexture: new THREE.DepthTexture(width, height), samples: 4 });
        const composer = new EffectComposer(renderer, target);
        
        const renderPass = new RenderPass(scene, camera);
        renderPass.clearColor = new THREE.Color(0x000000); 
        renderPass.clearAlpha = 0;
        composer.addPass(renderPass);

        // SSAO - Standard
        const ssaoPass = new SSAOPass(scene, camera, width, height);
        composer.addPass(ssaoPass);
        
        // GTAO - High Quality
        const gtaoPass = new GTAOPass(scene, camera, width, height);
        gtaoPass.enabled = false;
        composer.addPass(gtaoPass);

        const bokehPass = new BokehPass(scene, camera, { focus: 1980, aperture: 0.0001, maxblur: 0.01 });
        
        // Enhance Bokeh Quality (High Quality settings: Rings=5, Samples=8)
        if (bokehPass.materialBokeh) {
            bokehPass.materialBokeh.defines['RINGS'] = 5;
            bokehPass.materialBokeh.defines['SAMPLES'] = 8;
            bokehPass.materialBokeh.needsUpdate = true;
        }

        composer.addPass(bokehPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(width, height), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        // Noise Pass
        const noisePass = new ShaderPass(NoiseShader);
        composer.addPass(noisePass);

        const rgbPass = new ShaderPass(RGBShiftShader);
        rgbPass.uniforms['amount'].value = 0.001;
        composer.addPass(rgbPass);
        
        composer.addPass(new OutputPass());

        ctx.current = { renderer, scene, camera, controls, composer, ambLight, dirLight, hemiLight, volGroup, floorGroup, ssaoPass, gtaoPass, bokehPass, bloomPass, noisePass, rgbPass, roomEnv };

        const onResize = () => {
          const w = window.innerWidth, h = window.innerHeight;
          camera.aspect = w / h; camera.updateProjectionMatrix();
          renderer.setSize(w, h); composer.setSize(w, h);
          ssaoPass.setSize(w, h);
          gtaoPass.setSize(w, h);
        };
        window.addEventListener('resize', onResize);

        return () => {
          window.removeEventListener('resize', onResize);
          renderer.dispose();
          containerRef.current?.removeChild(renderer.domElement);
          if (ctx.current.animId) cancelAnimationFrame(ctx.current.animId);
        };
      }, []);

      // Update Uniforms & Pass States
      useEffect(() => {
        const c = ctx.current;
        if (!c.composer) return;
        
        const isPlaster = config.materialType === 'plaster';
        const isWax = config.materialType === 'wax';

        // Always apply user configured bloom strength
        c.bloomPass.strength = config.bloomStrength;

        // Lighting Logic
        if (isPlaster || isWax) {
            c.ambLight.intensity = isWax ? 0.3 : 0.2; 
            c.dirLight.intensity = isWax ? 1.5 : 2.0; 
            c.hemiLight.intensity = isWax ? 0.2 : 0.15; 
            c.scene.background = null; 
            c.ssaoPass.enabled = false;
            c.gtaoPass.enabled = true;
            c.gtaoPass.updateGtaoMaterial({ 
                radius: 10, distanceExponent: 1, thickness: 5, scale: 1.5, samples: 32
            });
            c.bloomPass.enabled = true;
            c.bloomPass.radius = 0.5;
            c.bloomPass.threshold = 0.7; 
        } else {
            c.ambLight.intensity = config.ambientLightBrightness * 0.01;
            c.dirLight.intensity = 0.5;
            c.hemiLight.intensity = 0.0;
            c.scene.background = null; 
            c.ssaoPass.enabled = config.enableSSAO;
            c.ssaoPass.kernelRadius = config.ssaoRadius;
            c.ssaoPass.minDistance = config.ssaoMinDist;
            c.ssaoPass.maxDistance = config.ssaoMaxDist;
            c.gtaoPass.enabled = false;
            c.bloomPass.enabled = true;
            c.bloomPass.radius = config.bloomRadius;
            c.bloomPass.threshold = config.bloomThreshold;
        }

        // Volume Lights Logic
        if (config.enableVolumeLights) {
            // Darken scene to make lights pop
            c.ambLight.intensity = 0.05;
            c.dirLight.intensity = 0.05;
            c.hemiLight.intensity = 0.0;

            // Populate volume lights if empty
            if (c.volGroup.children.length === 0) {
                const width = 600;
                const height = 600; // Square
                const intensity = 70.0; // Reduced from 100.0 (30% less)
                const dist = 1200; // Further out

                const createVolumetricLight = (color, x, z, yRot) => {
                    const rectLight = new THREE.RectAreaLight(color, intensity, width, height);
                    rectLight.position.set(x, 0, z); // Centered vertically
                    
                    // Only the light source remains
                    
                    rectLight.lookAt(0, 0, 0); // Face center
                    return rectLight;
                };

                const red = createVolumetricLight(0xff0000, dist, 0);
                const green = createVolumetricLight(0x00ff00, -dist/2, dist*0.866);
                const blue = createVolumetricLight(0x0000ff, -dist/2, -dist*0.866);

                c.volGroup.add(red, green, blue);
            }
            c.volGroup.visible = true;
        } else {
            c.volGroup.visible = false;
        }

        // Reflective Floor Visibility
        if (c.floorGroup) {
            c.floorGroup.visible = config.enableReflectiveFloor;
        }

        // Fog Logic
        if (config.enableFog) {
            c.scene.fog = new THREE.Fog(0x000000, 1000, 4000);
            c.scene.background = null; 
        } else {
            c.scene.fog = null;
            c.scene.background = null;
        }

        // DoF
        c.bokehPass.enabled = config.enableDoF;
        c.bokehPass.uniforms.focus.value = config.focus;
        c.bokehPass.uniforms.aperture.value = config.aperture;
        c.bokehPass.uniforms.maxblur.value = config.maxBlur;

        // RGB
        c.rgbPass.enabled = config.enableRGB;

        // Noise
        if (c.noisePass) {
            c.noisePass.uniforms.uOpacity.value = config.noiseOpacity;
            const modeMap = { 'overlay': 0, 'multiply': 1, 'additive': 2, 'softlight': 3 };
            c.noisePass.uniforms.uBlendMode.value = modeMap[config.noiseBlendMode] || 0;
        }

      }, [config]);

      // Recreate Mesh on Material/Resolution change
      useEffect(() => {
        const c = ctx.current;
        if (!c.scene) return;

        if (c.mesh) {
            c.scene.remove(c.mesh);
            c.mesh.geometry.dispose();
            c.mesh.material.dispose();
        }

        const injectSlicing = (shader) => {
          shader.uniforms.uSliced = { value: config.slicedMode ? 1.0 : 0.0 };
          shader.vertexShader = `varying vec3 vPos;\n` + shader.vertexShader.replace('#include <begin_vertex>', '#include <begin_vertex>\nvPos = position;');
          shader.fragmentShader = `uniform float uSliced;\nvarying vec3 vPos;\n` + shader.fragmentShader.replace('void main() {', 'void main() {\n if (uSliced > 0.5 && smoothstep(0.98, 1.0, sin(vPos.y * 200.0)) < 0.1) discard;');
        };

        let material;
        if (config.materialType === 'wax') {
            // Realistic Wax Material without noise
            material = new THREE.MeshPhysicalMaterial({
                color: config.color,
                metalness: 0.1,
                roughness: 0.35, 
                transmission: 0.5, // Increased transmission for better SSS look
                thickness: 500, // Adjusted thickness to match scale roughly
                ior: 1.44, 
                side: THREE.DoubleSide,
                envMapIntensity: 1.0,
                clearcoat: 0.5,
                clearcoatRoughness: 0.2,
                attenuationDistance: 400, // Increased significantly so it's not black
                attenuationColor: new THREE.Color(config.color).offsetHSL(0, 0.1, -0.1)
            });

            material.onBeforeCompile = (shader) => {
              injectSlicing(shader);
              material.userData.shader = shader;
            };

        } else if (config.materialType === 'water') {
            material = new THREE.MeshPhysicalMaterial({
                color: config.color, metalness: 0.5, roughness: 0,
                transmission: 1.0, thickness: 5, ior: 1.33,
                side: THREE.DoubleSide, envMapIntensity: 2.0,
                clearcoat: 1.0, transparent: true, opacity: 0.05
            });
            material.onBeforeCompile = (shader) => {
              injectSlicing(shader);
              material.userData.shader = shader;
            };
        } else if (config.materialType === 'plaster') {
            material = new THREE.MeshPhysicalMaterial({
                color: config.color, 
                metalness: 0.0, 
                roughness: 0.8,
                clearcoat: 0.0, 
                side: THREE.DoubleSide,
                dithering: true
            });
             material.onBeforeCompile = (shader) => {
              injectSlicing(shader);
              material.userData.shader = shader;
            };
        } else {
            material = new THREE.ShaderMaterial({
              uniforms: { uColor: { value: new THREE.Color(config.color) }, uSliced: { value: config.slicedMode ? 1.0 : 0.0 } },
              vertexShader: `varying vec3 vPos; void main() { vPos = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
              fragmentShader: `uniform vec3 uColor; uniform float uSliced; varying vec3 vPos; void main() { 
                  float line = smoothstep(0.98, 0.999, sin(vPos.y * 200.0));
                  if (uSliced > 0.5 && line < 0.1) discard;
                  gl_FragColor = vec4(uColor * line, 1.0); 
              }`,
              side: THREE.DoubleSide
            });
        }

        const mesh = new MarchingCubes(config.resolution, material, true, true, 100000);
        mesh.position.set(0, 0, 0);
        mesh.scale.set(800, 800, 800);
        mesh.enableUvs = false; mesh.enableColors = false;
        mesh.castShadow = true; mesh.receiveShadow = true;
        
        c.scene.add(mesh);
        c.mesh = mesh;
      }, [config.resolution, config.color, config.materialType]); 

      // Animation Loop
      useEffect(() => {
        const c = ctx.current;
        if (!c.scene) return;

        let time = 0;
        const animate = () => {
          c.animId = requestAnimationFrame(animate);
          time += 0.01 * config.speed;
          
          if (config.enableVolumeLights && c.volGroup.visible) {
             c.volGroup.rotation.y = -time * 0.1; // Rotate lights
          }

          // Update Noise Time
          if (c.noisePass) {
             c.noisePass.uniforms.uTime.value += 0.05;
          }

          if (c.mesh) {
            c.mesh.reset();
            const strength = 1.2 / ((Math.sqrt(config.numBlobs) - 1) / 4 + 1);
            
            for (let i = 0; i < config.numBlobs; i++) {
                const grp = Math.floor(i / 4), sub = i % 4;
                const cycle = time * 0.5 + grp;
                const stage = Math.sin(cycle) + 1; 
                
                const range = 0.22;
                const gx = Math.sin(grp * 13.4 + time * 0.5) * range + 0.5;
                const gy = Math.cos(grp * 21.6 + time * 0.4) * range + 0.5;
                const gz = Math.sin(grp * 45.2 + time * 0.6) * range + 0.5;

                const sp1 = THREE.MathUtils.smoothstep(stage, 0.2, 0.8) * 0.12;
                const sp2 = THREE.MathUtils.smoothstep(stage, 1.2, 1.8) * 0.08;
                
                let ox = (sub < 2 ? -sp1 : sp1);
                let oy = (sub % 2 === 0 ? -sp2 : sp2);
                
                const rot = time * 0.3 + grp, cR = Math.cos(rot), sR = Math.sin(rot);
                const rx = ox * cR - oy * sR, ry = ox * sR + oy * cR;
                
                const wx = Math.sin(time * 2 + i) * 0.02;
                const wy = Math.cos(time * 2.1 + i) * 0.02;

                let fx = gx + rx + wx;
                let fy = gy + ry + wy;
                let fz = gz + wx;
                
                const margin = 0.25; 
                fx = Math.max(margin, Math.min(1.0 - margin, fx));
                fy = Math.max(margin, Math.min(1.0 - margin, fy));
                fz = Math.max(margin, Math.min(1.0 - margin, fz));

                c.mesh.addBall(fx, fy, fz, strength, 12);
            }
            
            if (config.floor) c.mesh.addPlaneY(2, 12);
            if (config.wallZ) c.mesh.addPlaneZ(2, 12);
            if (config.wallX) c.mesh.addPlaneX(2, 12);
            
            c.mesh.isolation = config.isolation;
            c.mesh.update();
            c.mesh.rotation.set(Math.sin(time * 0.5) + Math.sin(time * 0.32) * 2, Math.cos(time * 0.4) + Math.sin(time * 0.15) * 2, 0);

            const mat = c.mesh.material;
            const isSliced = config.slicedMode ? 1.0 : 0.0;
            if (config.materialType === 'striped') {
                if (mat.uniforms) {
                    mat.uniforms.uColor.value.set(config.color);
                    mat.uniforms.uSliced.value = isSliced;
                }
            } else {
                mat.color.set(config.color);
                if (mat.userData.shader?.uniforms) mat.userData.shader.uniforms.uSliced.value = isSliced;
            }
          }
          
          // Dynamic Floor Collision
          const dist = c.controls.getDistance();
          const floorHeight = -800;
          const safeHeight = floorHeight + 20; 
          
          if (dist > Math.abs(safeHeight)) {
             c.controls.maxPolarAngle = Math.acos(safeHeight / dist);
          } else {
             c.controls.maxPolarAngle = Math.PI;
          }

          c.controls.update();
          c.composer.render();
        };
        
        if (!c.animId) animate();
        return () => {
            if (c.animId) { cancelAnimationFrame(c.animId); c.animId = null; }
        };
      }, [config]);

      return <div ref={containerRef} className="absolute inset-0 z-10 cursor-move" />;
    };

    const App = () => {
      const [config, setConfig] = useState(DEFAULT_CONFIG);
      return (
        <div className="relative w-full h-screen overflow-hidden">
          <ControlPanel config={config} setConfig={setConfig} />
          <ThreeScene config={config} />
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
