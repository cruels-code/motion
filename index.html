<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>motion by cruel.tez</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <style>
    body { margin: 0; overflow: hidden; background-color: #000; color: #e2e8f0; font-family: 'Montserrat', sans-serif; }
    button, input, select, textarea { font-family: inherit; }
    canvas { display: block; touch-action: none; outline: none; }
    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    
    input[type=range] { -webkit-appearance: none; background: transparent; }
    input[type=range]:focus { outline: none; }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%;
      background: #ffffff; margin-top: -5px; box-shadow: 0 0 10px rgba(255,255,255,0.5); cursor: pointer;
    }
    input[type=range]::-webkit-slider-runnable-track {
      width: 100%; height: 4px; cursor: pointer; background: rgba(255,255,255,0.1); border-radius: 2px;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0",
        "three": "https://esm.sh/three@0.160.0",
        "three/examples/jsm/": "https://esm.sh/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef } from 'react';
    import ReactDOM from 'react-dom/client';
    import { Settings2, RotateCcw, X, Lightbulb, Waves, Smartphone } from 'lucide-react';
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
    import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes';
    import { Reflector } from 'three/examples/jsm/objects/Reflector.js';
    import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
    import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
    import { RGBShiftShader } from 'three/examples/jsm/shaders/RGBShiftShader';
    import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader';
    import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
    import { BokehPass } from 'three/examples/jsm/postprocessing/BokehPass';
    import { SSAOPass } from 'three/examples/jsm/postprocessing/SSAOPass';
    import { GTAOPass } from 'three/examples/jsm/postprocessing/GTAOPass';
    import { RectAreaLightUniformsLib } from 'three/examples/jsm/lights/RectAreaLightUniformsLib.js';

    // Voronoi shader for generating water caustic effects
    const CausticsShader = {
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float uTime;
        
        vec2 hash2(vec2 p) {
            p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
            return fract(sin(p) * 43758.5453);
        }

        float voronoi(vec2 uv, float t) {
            vec2 n = floor(uv);
            vec2 f = fract(uv);
            float m_dist = 1.0;
            
            for(int j=-1; j<=1; j++) {
                for(int i=-1; i<=1; i++) {
                    vec2 g = vec2(float(i), float(j));
                    vec2 o = hash2(n + g);
                    o = 0.5 + 0.5 * sin(t + 6.2831 * o);
                    vec2 r = g + o - f;
                    float d = dot(r, r);
                    if(d < m_dist) m_dist = d;
                }
            }
            return sqrt(m_dist);
        }

        void main() {
            float time = uTime * 0.6;
            vec2 uv = vUv * 6.0;
            
            float v1 = voronoi(uv, time);
            float v2 = voronoi(uv * 1.2 + vec2(4.0), time * 0.8 + 10.0);
            
            float i1 = smoothstep(0.0, 0.6, v1);
            i1 = pow(i1, 16.0);
            
            float i2 = smoothstep(0.0, 0.6, v2);
            i2 = pow(i2, 16.0);
            
            float intensity = clamp((i1 * 0.6 + i2 * 0.4) * 4.0, 0.0, 1.0);
            
            vec3 waterColor = vec3(0.1, 0.9, 0.9);
            vec3 col = waterColor * intensity;
            col += vec3(0.0, 0.1, 0.2) * 0.1;

            gl_FragColor = vec4(col, 1.0);
        }
      `
    };

    const NoiseShader = {
      uniforms: {
        tDiffuse: { value: null },
        uTime: { value: 0 },
        uOpacity: { value: 0 },
        uBlendMode: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uOpacity;
        uniform int uBlendMode;
        varying vec2 vUv;

        float randStandard(vec2 co) {
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main() {
            vec4 base = texture2D(tDiffuse, vUv);
            vec2 seed = gl_FragCoord.xy * 0.01 + mod(uTime, 100.0);
            float noise = randStandard(seed * 100.0);
            vec3 result = base.rgb;
            
            if (uBlendMode == 0) { // Overlay
                for (int i = 0; i < 3; i++) {
                    float b = base.rgb[i];
                    result[i] = (b < 0.5) ? 2.0 * b * noise : 1.0 - 2.0 * (1.0 - b) * (1.0 - noise);
                }
            } else if (uBlendMode == 1) { // Multiply
                result = base.rgb * noise;
            } else if (uBlendMode == 2) { // Additive
                result = base.rgb + noise;
            } else if (uBlendMode == 3) { // SoftLight
                for (int i = 0; i < 3; i++) {
                    float b = base.rgb[i];
                    result[i] = (1.0 - 2.0 * noise) * b * b + 2.0 * noise * b;
                }
            }
            gl_FragColor = vec4(mix(base.rgb, result, uOpacity), base.a);
        }
      `
    };

    const DEFAULT_CONFIG = {
      speed: 0.5, numBlobs: 60, blobSize: 1.0, resolution: 80, isolation: 80,
      floor: false, floorType: 'mirror', wallX: false, wallZ: false,
      color: '#ffffff', ambientLightBrightness: 80, materialType: 'organic',
      bloomStrength: 0.05, bloomRadius: 0.5, bloomThreshold: 0.9,
      focus: 1980.0, aperture: 0.00001, maxBlur: 0.01,
      enableSSAO: true, ssaoRadius: 16, ssaoMinDist: 0.005, ssaoMaxDist: 0.1,
      enableDoF: true, enableRGB: true, enableAA: true, slicedMode: true,
      enableVolumeLights: true, enableFog: true,
      noiseOpacity: 0.02, noiseBlendMode: 'softlight',
      enableEnvMap: false,
      enableProjector: true,
      projectorIntensity: 16.1,
      projectorAngle: 1.4,
      projectorPenumbra: 0.70,
      projectorHeight: 3000,
      projectorCaustics: true,
      pixelDoubling: false,
      mobileMode: false
    };

    const Toggle = ({ label, checked, onChange, icon }) => (
      <label className="flex items-center justify-between cursor-pointer group py-2">
        <div className="flex items-center gap-2">
           {icon && <span className="text-gray-400 group-hover:text-white transition-colors">{icon}</span>}
           <span className="text-gray-300 text-xs font-medium group-hover:text-white transition-colors tracking-wide">{label}</span>
        </div>
        <div className="relative">
          <input type="checkbox" checked={checked} onChange={(e) => onChange(e.target.checked)} className="sr-only peer" />
          <div className="w-9 h-5 bg-white/10 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white/80 after:border-gray-300 after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-indigo-600 peer-checked:after:bg-white shadow-inner"></div>
        </div>
      </label>
    );

    const ControlPanel = ({ config, setConfig, cameraStats }) => {
      const [isOpen, setIsOpen] = useState(false);
      const [isMobile, setIsMobile] = useState(false);
      const [isColorActive, setIsColorActive] = useState(false);
      const [isButtonVisible, setIsButtonVisible] = useState(true);
      const isHovering = useRef(false);
      const buttonTimer = useRef(null);
      const closeTimer = useRef(null);
      
      useEffect(() => {
        const check = () => setIsMobile(window.innerWidth < 768);
        check();
        window.addEventListener('resize', check);
        return () => window.removeEventListener('resize', check);
      }, []);

      useEffect(() => {
        if (!isOpen) {
             if (buttonTimer.current) clearTimeout(buttonTimer.current);
             buttonTimer.current = setTimeout(() => {
                 setIsButtonVisible(false);
             }, 7000);
        } else {
             if (buttonTimer.current) clearTimeout(buttonTimer.current);
             setIsButtonVisible(true);
        }
        return () => { if (buttonTimer.current) clearTimeout(buttonTimer.current); };
      }, [isOpen]);

      const update = (k, v) => setConfig(p => ({ ...p, [k]: v }));

      const panelClasses = isMobile 
        ? `fixed inset-0 z-[60] bg-[#050505]/95 backdrop-blur-xl p-6 overflow-y-auto transition-transform duration-500 cubic-bezier(0.16, 1, 0.3, 1) ${isOpen ? 'translate-y-0' : 'translate-y-full'}`
        : `absolute top-6 left-6 w-80 bg-[#080808]/60 backdrop-blur-2xl border border-white/5 rounded-2xl p-6 shadow-[0_20px_50px_-12px_rgba(0,0,0,1)] text-sm z-50 max-h-[90vh] overflow-y-auto transition-all duration-500 cubic-bezier(0.16, 1, 0.3, 1) scrollbar-hide ${isOpen ? 'opacity-100 pointer-events-auto translate-x-0' : 'opacity-0 pointer-events-none -translate-x-4'}`;

      const labelClass = "text-[10px] font-bold tracking-[0.2em] text-gray-500 uppercase mb-3 block";
      const valueClass = "font-mono text-indigo-400 text-[10px]";
      const borderClass = "border-white/5 my-6";
      const sectionClass = "mb-6";

      return (
        <>
          <div 
            className="absolute top-6 left-6 z-40" 
            onMouseEnter={() => {
                setIsButtonVisible(true);
                if (buttonTimer.current) clearTimeout(buttonTimer.current);
                if (closeTimer.current) clearTimeout(closeTimer.current);
                if (!isMobile) setIsOpen(true);
            }}
            onMouseLeave={() => {
                if (!isOpen) {
                     if (buttonTimer.current) clearTimeout(buttonTimer.current);
                     buttonTimer.current = setTimeout(() => setIsButtonVisible(false), 7000);
                }
            }}
          >
             <button onClick={() => setIsOpen(true)} className={`p-3 rounded-2xl bg-black/40 backdrop-blur-xl border border-white/10 text-white shadow-2xl transition-all duration-300 hover:bg-black/60 hover:scale-105 active:scale-95 group ${(isOpen && !isMobile) ? 'opacity-0 pointer-events-none' : (isButtonVisible ? 'opacity-100' : 'opacity-0')}`}>
               <Settings2 size={20} className="group-hover:rotate-90 transition-transform duration-700" />
             </button>
          </div>

          <div className={panelClasses} 
            onMouseEnter={() => { 
                isHovering.current = true; 
                if (closeTimer.current) clearTimeout(closeTimer.current);
            }} 
            onMouseLeave={() => { 
                isHovering.current = false; 
                if (!isMobile && !isColorActive) {
                    if (closeTimer.current) clearTimeout(closeTimer.current);
                    closeTimer.current = setTimeout(() => setIsOpen(false), 2000);
                }
            }}>
            <div className="flex justify-between mb-8 items-center">
              <div className="flex gap-3 items-center">
                <div className="p-1.5 bg-indigo-500/10 rounded-lg border border-indigo-500/20">
                  <Settings2 size={16} className="text-indigo-400" />
                </div>
                <h2 className="font-semibold text-white tracking-wide text-sm">CONFIGURATION</h2>
              </div>
              <div className="flex gap-2 items-center">
                <button onClick={() => setConfig(DEFAULT_CONFIG)} className="p-2 rounded-full hover:bg-white/10 transition-colors text-gray-400 hover:text-white" title="Reset to Defaults">
                  <RotateCcw size={14} />
                </button>
                {isMobile && (
                  <button onClick={() => setIsOpen(false)} className="p-2 bg-white/5 rounded-full text-gray-200">
                    <X size={18} />
                  </button>
                )}
              </div>
            </div>
            
            <div className="pb-4">
              <div className="mb-8">
                  <button 
                    onClick={() => {
                        const targetState = !config.mobileMode;
                        setConfig(prev => ({
                          ...prev, 
                          mobileMode: targetState,
                          ...(targetState ? {
                              pixelDoubling: true,
                              numBlobs: 35,
                              speed: 3,
                              resolution: 40,
                              enableProjector: false,
                              enableEnvMap: true
                          } : {
                              pixelDoubling: DEFAULT_CONFIG.pixelDoubling,
                              numBlobs: DEFAULT_CONFIG.numBlobs,
                              speed: DEFAULT_CONFIG.speed,
                              resolution: DEFAULT_CONFIG.resolution,
                              enableProjector: DEFAULT_CONFIG.enableProjector,
                              enableEnvMap: DEFAULT_CONFIG.enableEnvMap
                          })
                        }));
                    }}
                    className={`w-full py-3 rounded-xl text-xs font-bold tracking-widest uppercase transition-all shadow-lg flex items-center justify-center gap-2 ${config.mobileMode ? 'bg-[#050505] text-indigo-400 border border-indigo-500/20 shadow-indigo-900/10 hover:bg-[#0a0a0a]' : 'bg-indigo-600 hover:bg-indigo-500 text-white shadow-indigo-900/40'}`}
                  >
                    <Smartphone size={14} />
                    Mobile Mode: {config.mobileMode ? 'ON' : 'OFF'}
                  </button>
              </div>

              <div className={sectionClass}>
                <label className={labelClass}>Material Presets</label>
                <div className="grid grid-cols-5 gap-1.5">
                  {['Glass', 'Metal', 'Plastic', 'Organic', 'Lines'].map(type => (
                    <button key={type} onClick={() => update('materialType', type.toLowerCase())} 
                      className={`py-2 rounded-lg text-[9px] font-medium uppercase tracking-wider transition-all duration-300 border ${config.materialType === type.toLowerCase() ? 'bg-indigo-600/90 border-indigo-500/50 text-white shadow-lg shadow-indigo-900/50' : 'bg-white/5 border-transparent text-gray-400 hover:bg-white/10 hover:text-gray-200'}`}>
                      {type}
                    </button>
                  ))}
                </div>
              </div>

              <div className={sectionClass}>
                <label className={labelClass}>Base Chromaticity</label>
                <div className="flex items-center gap-3 p-1 pr-3 rounded-xl border border-white/5 bg-white/[0.02]">
                  <div className="relative overflow-hidden w-8 h-8 rounded-lg shadow-inner">
                    <input type="color" value={config.color} onChange={(e) => update('color', e.target.value)} onFocus={() => setIsColorActive(true)} onBlur={() => { setIsColorActive(false); if (!isMobile && !isHovering.current) { if(closeTimer.current) clearTimeout(closeTimer.current); closeTimer.current = setTimeout(() => setIsOpen(false), 2000); } }} className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[150%] h-[150%] cursor-pointer border-none p-0" />
                  </div>
                  <span className="font-mono text-xs text-gray-300 flex-1 text-center">{config.color.toUpperCase()}</span>
                </div>
              </div>

              <hr className={borderClass} />
              
              <div className={sectionClass}>
                <label className={labelClass}>Projector Light</label>
                <div className="space-y-4">
                  <Toggle label="Enable Projector" checked={config.enableProjector} onChange={(v) => update('enableProjector', v)} icon={<Lightbulb size={12} />} />
                  
                  {config.enableProjector && (
                    <div className="pl-2 border-l-2 border-white/10 space-y-4 animate-in fade-in slide-in-from-top-2 duration-300">
                      <div>
                        <div className="flex justify-between text-xs mb-1">
                          <span className="text-gray-400">Brightness</span>
                          <span className={valueClass}>{config.projectorIntensity.toFixed(1)}</span>
                        </div>
                        <input type="range" min="0" max="20" step="0.1" value={config.projectorIntensity} onChange={(e) => update('projectorIntensity', +e.target.value)} className="w-full" />
                      </div>

                      <div>
                        <div className="flex justify-between text-xs mb-1">
                          <span className="text-gray-400">Beam Angle</span>
                          <span className={valueClass}>{(config.projectorAngle * 57.29).toFixed(0)}Â°</span>
                        </div>
                        <input type="range" min="0.1" max="1.57" step="0.01" value={config.projectorAngle} onChange={(e) => update('projectorAngle', +e.target.value)} className="w-full" />
                      </div>

                      <div>
                        <div className="flex justify-between text-xs mb-1">
                          <span className="text-gray-400">Focus (Softness)</span>
                          <span className={valueClass}>{config.projectorPenumbra.toFixed(2)}</span>
                        </div>
                        <input type="range" min="0" max="1" step="0.01" value={config.projectorPenumbra} onChange={(e) => update('projectorPenumbra', +e.target.value)} className="w-full" />
                      </div>

                       <div>
                        <div className="flex justify-between text-xs mb-1">
                          <span className="text-gray-400">Height</span>
                          <span className={valueClass}>{config.projectorHeight.toFixed(0)}</span>
                        </div>
                        <input type="range" min="500" max="5500" step="50" value={config.projectorHeight} onChange={(e) => update('projectorHeight', +e.target.value)} className="w-full" />
                      </div>
                      
                      <Toggle label="Caustics" checked={config.projectorCaustics} onChange={(v) => update('projectorCaustics', v)} icon={<Waves size={12} />} />
                    </div>
                  )}
                </div>
              </div>

              <hr className={borderClass} />
              
              <div className={sectionClass}>
                <label className={labelClass}>Scene Effects</label>
                <div className="space-y-1">
                   <div className="mb-2">
                      <label className="text-[10px] font-bold tracking-[0.2em] text-gray-500 uppercase mb-2 block">Floor Type</label>
                      <div className="grid grid-cols-2 gap-2">
                         {['none', 'mirror'].map(type => (
                            <button key={type} onClick={() => update('floorType', type)} 
                               className={`py-2 rounded-lg text-[10px] font-medium uppercase tracking-wider transition-all duration-300 border ${config.floorType === type ? 'bg-indigo-600/90 border-indigo-500/50 text-white shadow-lg shadow-indigo-900/50' : 'bg-white/5 border-transparent text-gray-400 hover:bg-white/10 hover:text-gray-200'}`}>
                               {type}
                            </button>
                         ))}
                      </div>
                   </div>
                   <Toggle label="Environment Lighting" checked={config.enableEnvMap} onChange={(v) => update('enableEnvMap', v)} />
                   <Toggle label="Sliced Mode" checked={config.slicedMode} onChange={(v) => update('slicedMode', v)} />
                   <Toggle label="RGB Lights" checked={config.enableVolumeLights} onChange={(v) => update('enableVolumeLights', v)} />
                   <Toggle label="Volumetric Fog" checked={config.enableFog} onChange={(v) => update('enableFog', v)} />
                </div>
              </div>

              <hr className={borderClass} />

              <div className={sectionClass}>
                 <div className="flex justify-between items-end mb-3">
                   <label className="text-[10px] font-bold tracking-[0.2em] text-gray-500 uppercase">Bloom Strength</label>
                   <span className={valueClass}>{config.bloomStrength.toFixed(2)}</span>
                 </div>
                 <input type="range" min="0" max="3" step="0.05" value={config.bloomStrength} onChange={(e) => update('bloomStrength', +e.target.value)} className="w-full" />
              </div>
              
              <hr className={borderClass} />

              <div className={sectionClass}>
                 <div className="flex justify-between items-end mb-3">
                   <label className="text-[10px] font-bold tracking-[0.2em] text-gray-500 uppercase">Film Grain</label>
                   <span className={valueClass}>{Math.round(config.noiseOpacity * 100)}%</span>
                 </div>
                 <input type="range" min="0" max="1" step="0.01" value={config.noiseOpacity} onChange={(e) => update('noiseOpacity', +e.target.value)} className="w-full mb-4" />
                 
                 <div className="grid grid-cols-4 gap-1">
                  {['overlay', 'multiply', 'additive', 'softlight'].map(mode => (
                      <button key={mode} onClick={() => update('noiseBlendMode', mode)} title={mode} className={`py-2 rounded text-[10px] uppercase font-bold transition-all ${config.noiseBlendMode === mode ? 'bg-white/20 text-white' : 'bg-transparent text-gray-600 hover:text-gray-400'}`}>
                          {mode.slice(0,3)}
                      </button>
                  ))}
                 </div>
              </div>

              <hr className={borderClass} />

              <div className={sectionClass}>
                <div className="flex justify-between items-center mb-1">
                  <label className="text-[10px] font-bold tracking-[0.2em] text-gray-500 uppercase">AO Radius</label>
                  <Toggle label="" checked={config.enableSSAO} onChange={(v) => update('enableSSAO', v)} />
                </div>
                {config.enableSSAO && (
                  <div className="mt-2 animate-in fade-in slide-in-from-top-1 duration-300">
                     <div className="flex justify-between text-[10px] text-gray-500 mb-2"><span>Radius Size</span><span className={valueClass}>{config.ssaoRadius}</span></div>
                     <input type="range" min="1" max="32" value={config.ssaoRadius} onChange={(e) => update('ssaoRadius', +e.target.value)} className="w-full" />
                  </div>
                )}
              </div>

              <hr className={borderClass} />

              <div className={sectionClass}>
                <label className={labelClass}>Post Processing</label>
                <div className="space-y-1">
                   <Toggle label="Depth of Field" checked={config.enableDoF} onChange={(v) => update('enableDoF', v)} />
                   {config.enableDoF && (
                      <div className="mt-2 mb-3 pl-2 animate-in fade-in slide-in-from-top-1 duration-300 border-l-2 border-white/10">
                         <div className="flex justify-between text-[10px] text-gray-500 mb-1"><span>Focus Distance</span><span className={valueClass}>{config.focus.toFixed(0)}</span></div>
                         <input type="range" min="10" max="3000" step="10" value={config.focus} onChange={(e) => update('focus', +e.target.value)} className="w-full mb-2" />
                         
                         <div className="flex justify-between text-[10px] text-gray-500 mb-1"><span>Effect Strength</span><span className={valueClass}>{(config.aperture * 10000).toFixed(2)}</span></div>
                         <input type="range" min="0" max="0.0002" step="0.000001" value={config.aperture} onChange={(e) => update('aperture', +e.target.value)} className="w-full" />
                      </div>
                   )}
                   <Toggle label="RGB Shift" checked={config.enableRGB} onChange={(v) => update('enableRGB', v)} />
                   <Toggle label="Anti-Aliasing (FXAA)" checked={config.enableAA} onChange={(v) => update('enableAA', v)} />
                </div>
              </div>

              <hr className={borderClass} />

              <div className="space-y-5">
                {[
                  { label: 'Speed', key: 'speed', min: 0, max: 5, step: 0.1, fmt: v => v.toFixed(1) + 'x' },
                  { label: 'Blob Count', key: 'numBlobs', min: 5, max: 100, step: 1, fmt: v => v },
                  { label: 'Blob Size', key: 'blobSize', min: 0.1, max: 3.0, step: 0.1, fmt: v => v.toFixed(1) + 'x' },
                  { label: 'Resolution', key: 'resolution', min: 10, max: 200, step: 1, fmt: v => v }
                ].map(ctrl => (
                  <div key={ctrl.key}>
                    <div className="flex justify-between text-xs mb-2">
                        <span className="text-gray-300 font-medium">{ctrl.label}</span>
                        <span className={valueClass}>{ctrl.fmt(config[ctrl.key])}</span>
                    </div>
                    <input type="range" min={ctrl.min} max={ctrl.max} step={ctrl.step} value={config[ctrl.key]} onChange={(e) => update(ctrl.key, +e.target.value)} className="w-full" />
                  </div>
                ))}
              </div>

              <div className="mt-8 pt-4 border-t border-white/5 space-y-1">
                 <div className="flex justify-between text-[10px] text-gray-500 font-mono">
                    <span>CAM POS</span>
                    <span className="text-indigo-400">{cameraStats.x}, {cameraStats.y}, {cameraStats.z}</span>
                 </div>
                 <div className="flex justify-between text-[10px] text-gray-500 font-mono">
                    <span>ZOOM</span>
                    <span className="text-indigo-400">{cameraStats.zoom}</span>
                 </div>
              </div>
              
              <div className="mt-4 text-[10px] text-center text-gray-700 font-medium tracking-widest uppercase opacity-50">
                cruel.tez
              </div>
            </div>
          </div>
        </>
      );
    };

    const ThreeScene = ({ config, setCameraStats }) => {
      const containerRef = useRef(null);
      const ctx = useRef({});
      const configRef = useRef(config);
      const [ready, setReady] = useState(false);

      useEffect(() => {
        configRef.current = config;
      }, [config]);

      useEffect(() => {
        if (!containerRef.current) return;
        
        RectAreaLightUniformsLib.init();

        const width = window.innerWidth, height = window.innerHeight;
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, preserveDrawingBuffer: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.setClearColor(0x000000, 0);
        
        containerRef.current.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const pmrem = new THREE.PMREMGenerator(renderer);
        const roomEnv = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
        pmrem.dispose();

        const modelGroup = new THREE.Group();
        scene.add(modelGroup);

        const camera = new THREE.PerspectiveCamera(50, width / height, 1, 50000);
        camera.position.set(0, -300, 2400);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.minDistance = 200; controls.maxDistance = 4000; controls.enableDamping = true;

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(0, 2000, 0);
        dirLight.castShadow = true;
        Object.assign(dirLight.shadow.camera, { near: 0.5, far: 5000, left: -1000, right: 1000, top: 1000, bottom: -1000 });
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.bias = -0.0001;
        modelGroup.add(dirLight);

        const ambLight = new THREE.AmbientLight(0xffffff, 0.2);
        modelGroup.add(ambLight);
        
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.0);
        hemiLight.position.set(0, 2000, 0);
        modelGroup.add(hemiLight);
        
        const spotLight = new THREE.SpotLight(0xffffff, 1000);
        spotLight.position.set(0, 1000, 0);
        spotLight.angle = 0.5;
        spotLight.penumbra = 0.2;
        spotLight.decay = 0; 
        spotLight.distance = 0; 
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 2048;
        spotLight.shadow.mapSize.height = 2048;
        spotLight.shadow.bias = -0.0001;
        spotLight.shadow.camera.near = 100;
        spotLight.shadow.camera.far = 4000;
        spotLight.target.position.set(0, 0, 0);
        
        modelGroup.add(spotLight);
        modelGroup.add(spotLight.target); 

        const causticsTarget = new THREE.WebGLRenderTarget(512, 512);
        const causticsScene = new THREE.Scene();
        const causticsCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const causticsMaterial = new THREE.ShaderMaterial({
             uniforms: { uTime: { value: 0 } },
             vertexShader: CausticsShader.vertexShader,
             fragmentShader: CausticsShader.fragmentShader
        });
        const causticsQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), causticsMaterial);
        causticsScene.add(causticsQuad);

        const volGroup = new THREE.Group();
        modelGroup.add(volGroup);

        const floorGroup = new THREE.Group();
        modelGroup.add(floorGroup);
        
        const target = new THREE.WebGLRenderTarget(width, height, { type: THREE.HalfFloatType, depthTexture: new THREE.DepthTexture(width, height), samples: 4 });
        const composer = new EffectComposer(renderer, target);
        
        const renderPass = new RenderPass(scene, camera);
        renderPass.clearColor = new THREE.Color(0x000000); 
        renderPass.clearAlpha = 0;
        composer.addPass(renderPass);

        const ssaoPass = new SSAOPass(scene, camera, width, height);
        composer.addPass(ssaoPass);
        
        const gtaoPass = new GTAOPass(scene, camera, width, height);
        gtaoPass.enabled = false;
        composer.addPass(gtaoPass);

        const bokehPass = new BokehPass(scene, camera, { focus: 1980, aperture: 0.0001, maxblur: 0.01 });
        if (bokehPass.materialBokeh) {
            bokehPass.materialBokeh.defines['RINGS'] = 5;
            bokehPass.materialBokeh.defines['SAMPLES'] = 8;
            bokehPass.materialBokeh.needsUpdate = true;
        }
        composer.addPass(bokehPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(width, height), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        const noisePass = new ShaderPass(NoiseShader);
        composer.addPass(noisePass);

        const rgbPass = new ShaderPass(RGBShiftShader);
        rgbPass.uniforms['amount'].value = 0.001;
        composer.addPass(rgbPass);
        
        composer.addPass(new OutputPass());

        const fxaaPass = new ShaderPass(FXAAShader);
        const pixelRatio = renderer.getPixelRatio();
        fxaaPass.material.uniforms['resolution'].value.x = 1 / (width * pixelRatio);
        fxaaPass.material.uniforms['resolution'].value.y = 1 / (height * pixelRatio);
        composer.addPass(fxaaPass);

        ctx.current = { 
            renderer, scene, camera, controls, composer, 
            ambLight, dirLight, hemiLight, spotLight, 
            volGroup, floorGroup, modelGroup,
            ssaoPass, gtaoPass, bokehPass, bloomPass, noisePass, rgbPass, fxaaPass, 
            roomEnv,
            causticsTarget, causticsScene, causticsCamera, causticsMaterial
        };

        const onResize = () => {
          const w = window.innerWidth, h = window.innerHeight;
          camera.aspect = w / h; camera.updateProjectionMatrix();
          renderer.setSize(w, h); composer.setSize(w, h);
          ssaoPass.setSize(w, h);
          gtaoPass.setSize(w, h);
          if(ctx.current.fxaaPass) {
             const pxRatio = renderer.getPixelRatio();
             ctx.current.fxaaPass.material.uniforms['resolution'].value.x = 1 / (w * pxRatio);
             ctx.current.fxaaPass.material.uniforms['resolution'].value.y = 1 / (h * pxRatio);
          }
        };
        window.addEventListener('resize', onResize);

        // Mark scene as ready to trigger dependent effects
        setReady(true);

        return () => {
          window.removeEventListener('resize', onResize);
          renderer.dispose();
          containerRef.current?.removeChild(renderer.domElement);
          if (ctx.current.animId) cancelAnimationFrame(ctx.current.animId);
          causticsTarget.dispose();
          setReady(false);
        };
      }, []);

      useEffect(() => {
        if (!ready) return;
        const c = ctx.current;
        if (!c.floorGroup || !c.scene) return;

        while (c.floorGroup.children.length > 0) {
            const child = c.floorGroup.children[0];
            c.floorGroup.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                else child.material.dispose();
            }
        }

        if (config.floorType === 'mirror') {
             const mirrorGeo = new THREE.PlaneGeometry(50000, 50000);
             const groundMirror = new Reflector(mirrorGeo, {
                clipBias: 0.003,
                textureWidth: window.innerWidth * window.devicePixelRatio,
                textureHeight: window.innerHeight * window.devicePixelRatio,
                color: 0x000000
             });
             groundMirror.position.y = -800; 
             groundMirror.rotateX(-Math.PI / 2);
             c.floorGroup.add(groundMirror);
             
             const grid = new THREE.GridHelper(50000, 500, 0x111111, 0x111111);
             grid.position.y = -799;
             grid.material.transparent = true;
             grid.material.opacity = 0.5;
             c.floorGroup.add(grid);
        }
      }, [config.floorType, ready]);

      useEffect(() => {
        if (!ready) return;
        const c = ctx.current;
        if (!c.composer) return;
        
        c.bloomPass.strength = config.bloomStrength;

        let ambIntensity = 0;
        let dirIntensity = 0;
        let hemiIntensity = 0;

        const useGTAO = ['organic', 'plastic', 'metal', 'lines', 'plaster', 'wax'].includes(config.materialType);
        const isLines = config.materialType === 'lines';

        if (useGTAO) {
            ambIntensity = isLines ? 0.8 : 0.3; 
            dirIntensity = isLines ? 0.5 : 1.5; 
            hemiIntensity = isLines ? 0.0 : 0.2; 
            
            c.scene.background = null; 
            c.ssaoPass.enabled = false;
            c.gtaoPass.enabled = true;
            c.gtaoPass.updateGtaoMaterial({ radius: 10, distanceExponent: 1, thickness: 5, scale: 1.5, samples: 32 });
            c.bloomPass.enabled = true;
            c.bloomPass.radius = isLines ? 0.3 : 0.5;
            c.bloomPass.threshold = isLines ? 1.1 : 0.7; 
        } else {
            ambIntensity = config.ambientLightBrightness * 0.01;
            dirIntensity = 0.5;
            hemiIntensity = 0.0;
            
            c.scene.background = null; 
            c.ssaoPass.enabled = config.enableSSAO;
            c.ssaoPass.kernelRadius = config.ssaoRadius;
            c.ssaoPass.minDistance = config.ssaoMinDist;
            c.ssaoPass.maxDistance = config.ssaoMaxDist;
            c.gtaoPass.enabled = false;
            c.bloomPass.enabled = true;
            c.bloomPass.radius = config.bloomRadius;
            c.bloomPass.threshold = config.bloomThreshold;
        }

        if (config.enableVolumeLights) {
            ambIntensity = 0.05; 
            dirIntensity = 0.05; 
            hemiIntensity = 0.0;
            
            if (c.volGroup.children.length === 0) {
                const width = 600, height = 600, intensity = 70.0, dist = 1200;
                const createLight = (color, x, z) => {
                    const l = new THREE.RectAreaLight(color, intensity, width, height);
                    l.position.set(x, 0, z); l.lookAt(0, 0, 0); return l;
                };
                c.volGroup.add(createLight(0xff0000, dist, 0), createLight(0x00ff00, -dist/2, dist*0.866), createLight(0x0000ff, -dist/2, -dist*0.866));
            }
            c.volGroup.visible = true;
        } else {
            c.volGroup.visible = false;
        }

        if (config.enableProjector) {
            ambIntensity = 0.0;
            dirIntensity = 0.0;
            hemiIntensity = 0.0;
            c.volGroup.visible = false;
        }
        
        c.scene.environment = config.enableEnvMap ? c.roomEnv : null;

        c.ambLight.intensity = ambIntensity;
        c.dirLight.intensity = dirIntensity;
        c.hemiLight.intensity = hemiIntensity;
        
        if (c.spotLight) {
            c.spotLight.visible = config.enableProjector;
            if (config.enableProjector) {
               c.spotLight.intensity = config.projectorIntensity;
               c.spotLight.angle = config.projectorAngle;
               c.spotLight.penumbra = config.projectorPenumbra;
               c.spotLight.position.setY(config.projectorHeight);
            }
        }
        
        c.scene.fog = config.enableFog ? new THREE.Fog(0x000000, 1000, 4000) : null;
        
        c.bokehPass.enabled = config.enableDoF;
        c.bokehPass.uniforms.focus.value = config.focus;
        c.bokehPass.uniforms.aperture.value = config.aperture;
        c.bokehPass.uniforms.maxblur.value = config.maxBlur;

        c.rgbPass.enabled = config.enableRGB;
        if (c.fxaaPass) c.fxaaPass.enabled = config.enableAA;

        if (c.noisePass) {
            c.noisePass.uniforms.uOpacity.value = config.noiseOpacity;
            const modeMap = { 'overlay': 0, 'multiply': 1, 'additive': 2, 'softlight': 3 };
            c.noisePass.uniforms.uBlendMode.value = modeMap[config.noiseBlendMode] || 0;
        }

        const targetPixelRatio = config.pixelDoubling ? Math.min(window.devicePixelRatio, 2) / 2 : Math.min(window.devicePixelRatio, 2);
        c.renderer.setPixelRatio(targetPixelRatio);
        if (c.fxaaPass) {
             c.fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * targetPixelRatio);
             c.fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * targetPixelRatio);
        }

      }, [config, ready]);

      useEffect(() => {
        if (!ready) return;
        const c = ctx.current;
        if (!c.scene) return;

        if (c.mesh) {
            c.modelGroup.remove(c.mesh);
            c.mesh.geometry.dispose();
            c.mesh.material.dispose();
        }

        const injectSlicing = (shader) => {
            shader.uniforms.uSliced = { value: config.slicedMode ? 1.0 : 0.0 };
            shader.vertexShader = `varying vec3 vPos;\n` + shader.vertexShader.replace('#include <begin_vertex>', '#include <begin_vertex>\nvPos = position;');
            shader.fragmentShader = `uniform float uSliced;\nvarying vec3 vPos;\n` + shader.fragmentShader.replace('void main() {', 'void main() {\n if (uSliced > 0.5) { float y = vPos.y * 800.0 + 400.0; if (mod(y, 30.0) > 5.0) discard; }');
        };

        let material;
        switch (config.materialType) {
            case 'organic': 
            case 'wax':
                material = new THREE.MeshPhysicalMaterial({
                    color: config.color, metalness: 0.1, roughness: 0.35, transmission: 0.5, thickness: 500, ior: 1.44, side: THREE.DoubleSide, envMapIntensity: 1.0, clearcoat: 0.5, clearcoatRoughness: 0.2, attenuationDistance: 400, attenuationColor: new THREE.Color(config.color).offsetHSL(0, 0.1, -0.1)
                });
                break;
            case 'glass':
            case 'water':
                material = new THREE.MeshPhysicalMaterial({
                    color: config.color, metalness: 0.0, roughness: 0.0, transmission: 1.0, thickness: 10, ior: 1.5, side: THREE.DoubleSide, envMapIntensity: 2.0, clearcoat: 1.0, transparent: true
                });
                break;
            case 'metal':
                 material = new THREE.MeshPhysicalMaterial({
                    color: config.color, metalness: 1.0, roughness: 0.2, side: THREE.DoubleSide, envMapIntensity: 1.0, clearcoat: 0.1
                });
                break;
            case 'plastic':
                 material = new THREE.MeshPhysicalMaterial({
                    color: config.color, metalness: 0.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.05, side: THREE.DoubleSide, envMapIntensity: 0.5
                });
                break;
            case 'lines':
                material = new THREE.MeshPhysicalMaterial({
                    color: 0x000000, 
                    emissive: 0x000000, 
                    metalness: 0.0, 
                    roughness: 0.4,
                    side: THREE.DoubleSide
                });
                break;
            default:
                 material = new THREE.MeshPhysicalMaterial({
                    color: config.color, metalness: 0.0, roughness: 0.8, clearcoat: 0.0, side: THREE.DoubleSide, dithering: true
                });
        }

        if (config.materialType === 'lines') {
            material.onBeforeCompile = (shader) => {
                injectSlicing(shader);
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <emissivemap_fragment>',
                    `
                    #include <emissivemap_fragment>
                    float spacing = 10.0;
                    float linePixelWidth = 1.0; 
                    float y = vPos.y * 800.0;
                    float coord = y / spacing;
                    float f = fwidth(coord);
                    float dist = abs(fract(coord - 0.5) - 0.5);
                    float line = smoothstep(f * linePixelWidth, 0.0, dist);
                    diffuseColor.rgb = vec3(line);
                    `
                );
                material.userData.shader = shader;
            };
        } else {
            material.onBeforeCompile = (shader) => { injectSlicing(shader); material.userData.shader = shader; };
        }

        const mesh = new MarchingCubes(config.resolution, material, true, true, 100000);
        mesh.position.set(0, 0, 0);
        mesh.scale.set(800, 800, 800);
        mesh.enableUvs = false; mesh.enableColors = false;
        mesh.castShadow = true; mesh.receiveShadow = true;
        
        c.modelGroup.add(mesh);
        c.mesh = mesh;
      }, [config.resolution, config.color, config.materialType, ready]); 

      useEffect(() => {
        if (!ready) return;
        const c = ctx.current;
        if (!c.scene) return;

        let time = 0;
        
        c.renderer.setAnimationLoop((timestamp, frame) => {
          const cfg = configRef.current;
          time += 0.01 * cfg.speed;

          if (cfg.enableProjector && cfg.projectorCaustics && c.causticsMaterial) {
              c.causticsMaterial.uniforms.uTime.value += 0.01 * cfg.speed;
              c.renderer.setRenderTarget(c.causticsTarget);
              c.renderer.render(c.causticsScene, c.causticsCamera);
              c.renderer.setRenderTarget(null);
              if (c.spotLight) c.spotLight.map = c.causticsTarget.texture;
          } else if (c.spotLight) {
              c.spotLight.map = null;
          }
          
          if (cfg.enableVolumeLights && c.volGroup.visible) {
             c.volGroup.rotation.y = -time * 0.1; 
             c.volGroup.children.forEach(light => { light.intensity = 70.0; });
          }
          
          if (c.bloomPass) c.bloomPass.strength = cfg.bloomStrength;
          if (c.noisePass) c.noisePass.uniforms.uTime.value += 0.05; 

          if (c.mesh) {
            c.mesh.reset();
            let baseStrength = (1.2 / ((Math.sqrt(cfg.numBlobs) - 1) / 4 + 1)) * cfg.blobSize;

            for (let i = 0; i < cfg.numBlobs; i++) {
                const grp = Math.floor(i / 4), sub = i % 4;
                const cycle = time * 0.5 + grp;
                const stage = Math.sin(cycle) + 1; 
                const range = 0.22;
                const gx = Math.sin(grp * 13.4 + time * 0.5) * range + 0.5;
                const gy = Math.cos(grp * 21.6 + time * 0.4) * range + 0.5;
                const gz = Math.sin(grp * 45.2 + time * 0.6) * range + 0.5;
                const sp1 = THREE.MathUtils.smoothstep(stage, 0.2, 0.8) * 0.12;
                const sp2 = THREE.MathUtils.smoothstep(stage, 1.2, 1.8) * 0.08;
                let ox = (sub < 2 ? -sp1 : sp1), oy = (sub % 2 === 0 ? -sp2 : sp2);
                const rot = time * 0.3 + grp, cR = Math.cos(rot), sR = Math.sin(rot);
                const rx = ox * cR - oy * sR, ry = ox * sR + oy * cR;
                const wx = Math.sin(time * 2 + i) * 0.02, wy = Math.cos(time * 2.1 + i) * 0.02;

                let fx = gx + rx + wx, fy = gy + ry + wy, fz = gz + wx;
                const margin = 0.25; 
                fx = Math.max(margin, Math.min(1.0 - margin, fx));
                fy = Math.max(margin, Math.min(1.0 - margin, fy));
                fz = Math.max(margin, Math.min(1.0 - margin, fz));
                c.mesh.addBall(fx, fy, fz, baseStrength, 12);
            }
            
            if (cfg.floor) c.mesh.addPlaneY(2, 12);
            if (cfg.wallZ) c.mesh.addPlaneZ(2, 12);
            if (cfg.wallX) c.mesh.addPlaneX(2, 12);

            if (c.mesh.material.userData.shader) {
                c.mesh.material.userData.shader.uniforms.uSliced.value = cfg.slicedMode ? 1.0 : 0.0;
            }
            
            c.mesh.isolation = cfg.isolation;
            c.mesh.update();
            c.mesh.rotation.set(Math.sin(time * 0.5) + Math.sin(time * 0.32) * 2, Math.cos(time * 0.4) + Math.sin(time * 0.15) * 2, 0);
            c.mesh.material.color.set(cfg.color);
          }
          
          const dist = c.controls.getDistance();
          const safeHeight = -780; 
          c.controls.maxPolarAngle = (dist > Math.abs(safeHeight)) ? Math.acos(safeHeight / dist) : Math.PI;

          c.controls.update();
          c.composer.render();

          if (Date.now() - (c.lastStatsUpdate || 0) > 200) {
             if (setCameraStats) {
                 setCameraStats({
                     x: Math.round(c.camera.position.x),
                     y: Math.round(c.camera.position.y),
                     z: Math.round(c.camera.position.z),
                     zoom: Math.round(c.controls.getDistance())
                 });
             }
             c.lastStatsUpdate = Date.now();
          }
        });
        
        return () => { c.renderer.setAnimationLoop(null); };
      }, [ready]);

      return <div ref={containerRef} className="absolute inset-0 z-10 cursor-move" />;
    };

    const App = () => {
      const [config, setConfig] = useState(() => {
         const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
         if (isMobile) {
             return {
                ...DEFAULT_CONFIG,
                mobileMode: true,
                pixelDoubling: true,
                numBlobs: 35,
                speed: 3,
                resolution: 40,
                enableProjector: false,
                enableEnvMap: true
             };
         }
         return DEFAULT_CONFIG;
      });
      const [cameraStats, setCameraStats] = useState({ x: 0, y: -300, z: 2400, zoom: 2400 });

      return (
        <div className="relative w-full h-screen overflow-hidden">
          <ControlPanel config={config} setConfig={setConfig} cameraStats={cameraStats} />
          <ThreeScene config={config} setCameraStats={setCameraStats} />
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
