<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>motion</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; color: #e2e8f0; font-family: system-ui, sans-serif; }
    canvas { display: block; }
    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0",
        "three": "https://esm.sh/three@0.160.0",
        "three/examples/jsm/": "https://esm.sh/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef } from 'react';
    import ReactDOM from 'react-dom/client';
    import { Settings2, RotateCcw } from 'lucide-react';
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
    import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes';
    import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
    import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
    import { RGBShiftShader } from 'three/examples/jsm/shaders/RGBShiftShader';
    import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
    import { BokehPass } from 'three/examples/jsm/postprocessing/BokehPass';
    import { SSAOPass } from 'three/examples/jsm/postprocessing/SSAOPass';
    import { GTAOPass } from 'three/examples/jsm/postprocessing/GTAOPass';
    import { RectAreaLightUniformsLib } from 'three/examples/jsm/lights/RectAreaLightUniformsLib.js';
    import { RectAreaLightHelper } from 'three/examples/jsm/helpers/RectAreaLightHelper.js';

    const DEFAULT_CONFIG = {
      speed: 0.5, numBlobs: 32, resolution: 60, isolation: 35,
      floor: false, wallX: false, wallZ: false,
      color: '#ffffff', ambientLightBrightness: 80, materialType: 'plaster',
      bloomStrength: 0.2, bloomRadius: 0.5, bloomThreshold: 0.9,
      focus: 1980.0, aperture: 0.00001, maxBlur: 0.01,
      enableSSAO: false, ssaoRadius: 16, ssaoMinDist: 0.005, ssaoMaxDist: 0.1,
      enableDoF: true, enableRGB: true, slicedMode: true,
      enableVolumeLights: true, enableFog: true,
    };

    const ControlPanel = ({ config, setConfig }) => {
      const update = (k, v) => setConfig(p => ({ ...p, [k]: v }));
      return (
        <div className="absolute top-4 left-4 w-80 bg-white/90 backdrop-blur-md border border-slate-200 rounded-xl p-5 shadow-2xl text-sm z-50 max-h-[90vh] overflow-y-auto opacity-0 hover:opacity-100 transition-opacity duration-300 scrollbar-hide text-slate-800">
          <div className="flex justify-between mb-6 text-indigo-600">
            <div className="flex gap-2"><Settings2 size={20} /><h2 className="font-bold tracking-wider">Controls</h2></div>
            <button onClick={() => setConfig(DEFAULT_CONFIG)} className="p-1 hover:bg-slate-100 rounded-full text-slate-400 hover:text-slate-700"><RotateCcw size={16} /></button>
          </div>
          
          <div className="space-y-5">
            <div className="space-y-2">
              <label className="text-xs font-semibold text-slate-500 uppercase">Material</label>
              <div className="flex gap-2">
                {['striped', 'water', 'plaster'].map(type => (
                  <button key={type} onClick={() => update('materialType', type)} 
                    className={`flex-1 py-2 rounded-lg border text-xs font-bold capitalize transition-colors ${config.materialType === type ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-slate-100 border-slate-200 text-slate-500 hover:bg-slate-200'}`}>
                    {type}
                  </button>
                ))}
              </div>
            </div>

            <div className="space-y-2">
              <label className="text-xs font-semibold text-slate-500 uppercase">Base Color</label>
              <div className="flex items-center gap-3 bg-slate-100 p-2 rounded-lg border border-slate-200">
                <input type="color" value={config.color} onChange={(e) => update('color', e.target.value)} className="w-8 h-8 cursor-pointer bg-transparent border-none p-0" />
                <span className="font-mono text-slate-600">{config.color}</span>
              </div>
            </div>

            <hr className="border-slate-200" />
            
            <div className="space-y-2">
              <label className="text-xs font-semibold text-slate-500 uppercase">Effects</label>
              <label className="flex items-center gap-3 cursor-pointer group pt-1">
                <input type="checkbox" checked={config.slicedMode} onChange={(e) => update('slicedMode', e.target.checked)} className="accent-indigo-500" />
                <span className="text-slate-700">Sliced Mode</span>
              </label>
              <label className="flex items-center gap-3 cursor-pointer group pt-1">
                <input type="checkbox" checked={config.enableVolumeLights} onChange={(e) => update('enableVolumeLights', e.target.checked)} className="accent-indigo-500" />
                <span className="text-slate-700">Volume Lights</span>
              </label>
               <label className="flex items-center gap-3 cursor-pointer group pt-1">
                <input type="checkbox" checked={config.enableFog} onChange={(e) => update('enableFog', e.target.checked)} className="accent-indigo-500" />
                <span className="text-slate-700">Fog</span>
              </label>
            </div>

            <hr className="border-slate-200" />

            <div className="space-y-2">
              <div className="flex justify-between">
                <label className="text-xs font-semibold text-slate-500 uppercase">Ambient Occlusion</label>
                <input type="checkbox" checked={config.enableSSAO} onChange={(e) => update('enableSSAO', e.target.checked)} className="accent-indigo-500" />
              </div>
              {config.enableSSAO && (
                <div className="pl-2 border-l-2 border-indigo-100 mt-2">
                   <div className="flex justify-between text-[10px] text-slate-400"><span>Radius</span><span className="font-mono text-indigo-500">{config.ssaoRadius}</span></div>
                   <input type="range" min="1" max="32" value={config.ssaoRadius} onChange={(e) => update('ssaoRadius', +e.target.value)} className="w-full accent-indigo-500 h-1 bg-slate-200 rounded-lg appearance-none" />
                </div>
              )}
            </div>

            <hr className="border-slate-200" />

            <div className="space-y-2">
              <label className="text-xs font-semibold text-slate-500 uppercase">Post Processing</label>
              <div className="space-y-1">
                <label className="flex items-center gap-3 cursor-pointer"><input type="checkbox" checked={config.enableDoF} onChange={(e) => update('enableDoF', e.target.checked)} className="accent-indigo-500" /><span className="text-slate-700">Depth of Field</span></label>
                <label className="flex items-center gap-3 cursor-pointer"><input type="checkbox" checked={config.enableRGB} onChange={(e) => update('enableRGB', e.target.checked)} className="accent-indigo-500" /><span className="text-slate-700">RGB Shift</span></label>
              </div>
            </div>

            <hr className="border-slate-200" />

            <div className="space-y-3">
              {[
                { label: 'Speed', key: 'speed', min: 0, max: 5, step: 0.1, fmt: v => v.toFixed(1) + 'x' },
                { label: 'Resolution', key: 'resolution', min: 10, max: 100, step: 1, fmt: v => v }
              ].map(ctrl => (
                <div key={ctrl.key} className="space-y-1">
                  <div className="flex justify-between text-xs font-semibold text-slate-500"><span>{ctrl.label}</span><span className="font-mono text-indigo-500">{ctrl.fmt(config[ctrl.key])}</span></div>
                  <input type="range" min={ctrl.min} max={ctrl.max} step={ctrl.step} value={config[ctrl.key]} onChange={(e) => update(ctrl.key, +e.target.value)} className="w-full accent-indigo-500 h-1 bg-slate-200 rounded-lg appearance-none" />
                </div>
              ))}
            </div>
          </div>
        </div>
      );
    };

    const ThreeScene = ({ config }) => {
      const containerRef = useRef(null);
      const ctx = useRef({}); // Context to store refs

      // Initialize Scene
      useEffect(() => {
        if (!containerRef.current) return;
        
        // Init RectAreaLight Uniforms
        RectAreaLightUniformsLib.init();

        const width = window.innerWidth, height = window.innerHeight;
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, preserveDrawingBuffer: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.setClearColor(0x000000, 0);
        containerRef.current.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const pmrem = new THREE.PMREMGenerator(renderer);
        const roomEnv = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
        scene.environment = roomEnv;
        pmrem.dispose();

        const camera = new THREE.PerspectiveCamera(50, width / height, 1, 50000);
        camera.position.set(0, 0, 2400);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.minDistance = 200; controls.maxDistance = 4000; controls.enableDamping = true;

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(0, 2000, 0);
        dirLight.castShadow = true;
        Object.assign(dirLight.shadow.camera, { near: 0.5, far: 5000, left: -1000, right: 1000, top: 1000, bottom: -1000 });
        dirLight.shadow.mapSize.set(2048, 2048);
        scene.add(dirLight);

        const ambLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambLight);
        
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.0);
        hemiLight.position.set(0, 2000, 0);
        scene.add(hemiLight);

        // Volume Lights Group
        const volGroup = new THREE.Group();
        scene.add(volGroup);

        // Post-processing
        const target = new THREE.WebGLRenderTarget(width, height, { type: THREE.HalfFloatType, depthTexture: new THREE.DepthTexture(width, height), samples: 4 });
        const composer = new EffectComposer(renderer, target);
        
        const renderPass = new RenderPass(scene, camera);
        renderPass.clearColor = new THREE.Color(0x000000); 
        renderPass.clearAlpha = 0;
        composer.addPass(renderPass);

        // SSAO - Standard
        const ssaoPass = new SSAOPass(scene, camera, width, height);
        composer.addPass(ssaoPass);
        
        // GTAO - High Quality
        const gtaoPass = new GTAOPass(scene, camera, width, height);
        gtaoPass.enabled = false;
        composer.addPass(gtaoPass);

        const bokehPass = new BokehPass(scene, camera, { focus: 1980, aperture: 0.0001, maxblur: 0.01 });
        composer.addPass(bokehPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(width, height), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        const rgbPass = new ShaderPass(RGBShiftShader);
        rgbPass.uniforms['amount'].value = 0.001;
        composer.addPass(rgbPass);
        
        composer.addPass(new OutputPass());

        ctx.current = { renderer, scene, camera, controls, composer, ambLight, dirLight, hemiLight, volGroup, ssaoPass, gtaoPass, bokehPass, bloomPass, rgbPass, roomEnv };

        const onResize = () => {
          const w = window.innerWidth, h = window.innerHeight;
          camera.aspect = w / h; camera.updateProjectionMatrix();
          renderer.setSize(w, h); composer.setSize(w, h);
          ssaoPass.setSize(w, h);
          gtaoPass.setSize(w, h);
        };
        window.addEventListener('resize', onResize);

        return () => {
          window.removeEventListener('resize', onResize);
          renderer.dispose();
          containerRef.current?.removeChild(renderer.domElement);
          if (ctx.current.animId) cancelAnimationFrame(ctx.current.animId);
        };
      }, []);

      // Update Uniforms & Pass States
      useEffect(() => {
        const c = ctx.current;
        if (!c.composer) return;
        
        const isPlaster = config.materialType === 'plaster';

        // Lighting Logic
        if (isPlaster) {
            c.ambLight.intensity = 0.2; 
            c.dirLight.intensity = 2.0; 
            c.hemiLight.intensity = 0.15; 
            c.scene.background = null; 
            c.ssaoPass.enabled = false;
            c.gtaoPass.enabled = true;
            c.gtaoPass.updateGtaoMaterial({ 
                radius: 10, distanceExponent: 1, thickness: 5, scale: 1.5, samples: 32
            });
            c.bloomPass.enabled = true;
            c.bloomPass.strength = 0.2; 
            c.bloomPass.radius = 0.5;
            c.bloomPass.threshold = 0.7; 
        } else {
            c.ambLight.intensity = config.ambientLightBrightness * 0.01;
            c.dirLight.intensity = 0.5;
            c.hemiLight.intensity = 0.0;
            c.scene.background = null; 
            c.ssaoPass.enabled = config.enableSSAO;
            c.ssaoPass.kernelRadius = config.ssaoRadius;
            c.ssaoPass.minDistance = config.ssaoMinDist;
            c.ssaoPass.maxDistance = config.ssaoMaxDist;
            c.gtaoPass.enabled = false;
            c.bloomPass.enabled = true;
            c.bloomPass.strength = config.bloomStrength;
            c.bloomPass.radius = config.bloomRadius;
            c.bloomPass.threshold = config.bloomThreshold;
        }

        // Volume Lights Logic
        if (config.enableVolumeLights) {
            // Darken scene to make lights pop
            c.ambLight.intensity = 0.05;
            c.dirLight.intensity = 0.05;
            c.hemiLight.intensity = 0.0;

            // Populate volume lights if empty
            if (c.volGroup.children.length === 0) {
                const width = 600;
                const height = 600; // Square
                const intensity = 70.0; // Reduced from 100.0 (30% less)
                const dist = 1200; // Further out

                const createVolumetricLight = (color, x, z, yRot) => {
                    const rectLight = new THREE.RectAreaLight(color, intensity, width, height);
                    rectLight.position.set(x, 0, z); // Centered vertically
                    
                    // Only the light source remains
                    
                    rectLight.lookAt(0, 0, 0); // Face center
                    return rectLight;
                };

                const red = createVolumetricLight(0xff0000, dist, 0);
                const green = createVolumetricLight(0x00ff00, -dist/2, dist*0.866);
                const blue = createVolumetricLight(0x0000ff, -dist/2, -dist*0.866);

                c.volGroup.add(red, green, blue);
            }
            c.volGroup.visible = true;
        } else {
            c.volGroup.visible = false;
        }

        // Fog Logic
        if (config.enableFog) {
            c.scene.fog = new THREE.Fog(0x000000, 1000, 4000);
            c.scene.background = null; 
        } else {
            c.scene.fog = null;
            c.scene.background = null;
        }

        // DoF
        c.bokehPass.enabled = config.enableDoF;
        c.bokehPass.uniforms.focus.value = config.focus;
        c.bokehPass.uniforms.aperture.value = config.aperture;
        c.bokehPass.uniforms.maxblur.value = config.maxBlur;

        // RGB
        c.rgbPass.enabled = config.enableRGB;
      }, [config]);

      // Recreate Mesh on Material/Resolution change
      useEffect(() => {
        const c = ctx.current;
        if (!c.scene) return;

        if (c.mesh) {
            c.scene.remove(c.mesh);
            c.mesh.geometry.dispose();
            c.mesh.material.dispose();
        }

        const injectSlicing = (shader) => {
          shader.uniforms.uSliced = { value: config.slicedMode ? 1.0 : 0.0 };
          shader.vertexShader = `varying vec3 vPos;\n` + shader.vertexShader.replace('#include <begin_vertex>', '#include <begin_vertex>\nvPos = position;');
          shader.fragmentShader = `uniform float uSliced;\nvarying vec3 vPos;\n` + shader.fragmentShader.replace('void main() {', 'void main() {\n if (uSliced > 0.5 && smoothstep(0.98, 1.0, sin(vPos.y * 200.0)) < 0.1) discard;');
        };

        let material;
        if (config.materialType === 'water') {
            material = new THREE.MeshPhysicalMaterial({
                color: config.color, metalness: 0.5, roughness: 0,
                transmission: 1.0, thickness: 5, ior: 1.33,
                side: THREE.DoubleSide, envMapIntensity: 2.0,
                clearcoat: 1.0, transparent: true, opacity: 0.05
            });
            material.onBeforeCompile = (shader) => {
              injectSlicing(shader);
              material.userData.shader = shader;
            };
        } else if (config.materialType === 'plaster') {
            material = new THREE.MeshPhysicalMaterial({
                color: config.color, 
                metalness: 0.0, 
                roughness: 0.8,
                clearcoat: 0.0, 
                side: THREE.DoubleSide,
                dithering: true
            });
             material.onBeforeCompile = (shader) => {
              injectSlicing(shader);
              material.userData.shader = shader;
            };
        } else {
            material = new THREE.ShaderMaterial({
              uniforms: { uColor: { value: new THREE.Color(config.color) }, uSliced: { value: config.slicedMode ? 1.0 : 0.0 } },
              vertexShader: `varying vec3 vPos; void main() { vPos = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
              fragmentShader: `uniform vec3 uColor; uniform float uSliced; varying vec3 vPos; void main() { 
                  float line = smoothstep(0.98, 0.999, sin(vPos.y * 200.0));
                  if (uSliced > 0.5 && line < 0.1) discard;
                  gl_FragColor = vec4(uColor * line, 1.0); 
              }`,
              side: THREE.DoubleSide
            });
        }

        const mesh = new MarchingCubes(config.resolution, material, true, true, 100000);
        mesh.position.set(0, 0, 0);
        mesh.scale.set(800, 800, 800);
        mesh.enableUvs = false; mesh.enableColors = false;
        mesh.castShadow = true; mesh.receiveShadow = true;
        
        c.scene.add(mesh);
        c.mesh = mesh;
      }, [config.resolution, config.color, config.materialType]); 

      // Animation Loop
      useEffect(() => {
        const c = ctx.current;
        if (!c.scene) return;

        let time = 0;
        const animate = () => {
          c.animId = requestAnimationFrame(animate);
          time += 0.01 * config.speed;
          
          if (config.enableVolumeLights && c.volGroup.visible) {
             c.volGroup.rotation.y = -time * 0.1; // Rotate lights
          }

          if (c.mesh) {
            c.mesh.reset();
            const strength = 1.2 / ((Math.sqrt(config.numBlobs) - 1) / 4 + 1);
            
            for (let i = 0; i < config.numBlobs; i++) {
                const grp = Math.floor(i / 4), sub = i % 4;
                const cycle = time * 0.5 + grp;
                const stage = Math.sin(cycle) + 1; 
                
                const range = 0.22;
                const gx = Math.sin(grp * 13.4 + time * 0.5) * range + 0.5;
                const gy = Math.cos(grp * 21.6 + time * 0.4) * range + 0.5;
                const gz = Math.sin(grp * 45.2 + time * 0.6) * range + 0.5;

                const sp1 = THREE.MathUtils.smoothstep(stage, 0.2, 0.8) * 0.12;
                const sp2 = THREE.MathUtils.smoothstep(stage, 1.2, 1.8) * 0.08;
                
                let ox = (sub < 2 ? -sp1 : sp1);
                let oy = (sub % 2 === 0 ? -sp2 : sp2);
                
                const rot = time * 0.3 + grp, cR = Math.cos(rot), sR = Math.sin(rot);
                const rx = ox * cR - oy * sR, ry = ox * sR + oy * cR;
                
                const wx = Math.sin(time * 2 + i) * 0.02;
                const wy = Math.cos(time * 2.1 + i) * 0.02;

                let fx = gx + rx + wx;
                let fy = gy + ry + wy;
                let fz = gz + wx;
                
                const margin = 0.25; 
                fx = Math.max(margin, Math.min(1.0 - margin, fx));
                fy = Math.max(margin, Math.min(1.0 - margin, fy));
                fz = Math.max(margin, Math.min(1.0 - margin, fz));

                c.mesh.addBall(fx, fy, fz, strength, 12);
            }
            
            if (config.floor) c.mesh.addPlaneY(2, 12);
            if (config.wallZ) c.mesh.addPlaneZ(2, 12);
            if (config.wallX) c.mesh.addPlaneX(2, 12);
            
            c.mesh.isolation = config.isolation;
            c.mesh.update();
            c.mesh.rotation.set(Math.sin(time * 0.5) + Math.sin(time * 0.32) * 2, Math.cos(time * 0.4) + Math.sin(time * 0.15) * 2, 0);

            const mat = c.mesh.material;
            const isSliced = config.slicedMode ? 1.0 : 0.0;
            if (config.materialType === 'striped') {
                if (mat.uniforms) {
                    mat.uniforms.uColor.value.set(config.color);
                    mat.uniforms.uSliced.value = isSliced;
                }
            } else {
                mat.color.set(config.color);
                if (mat.userData.shader?.uniforms) mat.userData.shader.uniforms.uSliced.value = isSliced;
            }
          }
          
          c.controls.update();
          c.composer.render();
        };
        
        if (!c.animId) animate();
        return () => {
            if (c.animId) { cancelAnimationFrame(c.animId); c.animId = null; }
        };
      }, [config]);

      return <div ref={containerRef} className="absolute inset-0 z-10 cursor-move" />;
    };

    const App = () => {
      const [config, setConfig] = useState(DEFAULT_CONFIG);
      return (
        <div className="relative w-full h-screen overflow-hidden font-sans">
          <ControlPanel config={config} setConfig={setConfig} />
          <ThreeScene config={config} />
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
